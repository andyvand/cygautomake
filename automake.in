#!@PERL@
# -*- perl -*-
# @configure_input@

eval 'exec @PERL@ -S $0 ${1+"$@"}'
    if 0;

# automake - create Makefile.in from Makefile.am
# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
# Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

# Originally written by David Mackenzie <djm@gnu.ai.mit.edu>.
# Perl reimplementation by Tom Tromey <tromey@cygnus.com>.

require 5;

# Parameters set by configure.  Not to be changed.  NOTE: assign
# VERSION as string so that eg version 0.30 will print correctly.
$VERSION = "@VERSION@";
$PACKAGE = "@PACKAGE@";
$prefix = "@prefix@";
$am_dir = "@datadir@/@PACKAGE@";

# String constants.
$IGNORE_PATTERN = "^##([^#].*)?\$";
$WHITE_PATTERN = "^[ \t]*\$";
$COMMENT_PATTERN = "^#";
$TARGET_PATTERN="[\$a-zA-Z_.][-.a-zA-Z0-9_(){}/\$]*";
$RULE_PATTERN = "^($TARGET_PATTERN) *:([^=].*|)\$";
$SUFFIX_RULE_PATTERN = "^\\.([a-zA-Z0-9]+)\\.([a-zA-Z0-9]+)\$";
# Only recognize leading spaces, not leading tabs.  If we recognize
# leading tabs here then we need to make the reader smarter, because
# otherwise it will think rules like `foo=bar; \' are errors.
$MACRO_PATTERN = "^ *([A-Za-z0-9_]+)[ \t]*([:+]?)=[ \t]*(.*)\$";
$BOGUS_MACRO_PATTERN = "^ *([^ \t]*)[ \t]*([:+]?)=[ \t]*(.*)\$";
$GNITS_VERSION_PATTERN = "[0-9]+\\.[0-9]+([a-z]|\\.[0-9]+)?";
$IF_PATTERN = "^if[ \t]+\([A-Za-z][A-Za-z0-9_]*\)[ \t]*\(#.*\)?\$";
$ELSE_PATTERN = "^else[ \t]*\(#.*\)?\$";
$ENDIF_PATTERN = "^endif[ \t]*\(#.*\)?\$";
$PATH_PATTERN='(\\w|[/.-])+';
# This will pass through anything not of the prescribed form.
$INCLUDE_PATTERN = "^include[ \t]+((\\\$\\\(top_srcdir\\\)/${PATH_PATTERN})|(\\\$\\\(srcdir\\\)/${PATH_PATTERN})|([^/\\\$]${PATH_PATTERN}))[ \t]*(#.*)?\$";

# Some regular expressions.  One reason to put them here is that it
# makes indentation work better in Emacs.
$AC_CONFIG_AUX_DIR_PATTERN = "AC_CONFIG_AUX_DIR\\(([^)]+)\\)";
$AM_INIT_AUTOMAKE_PATTERN = "AM_INIT_AUTOMAKE\\([^,]*,([^,)]+)[,)]";
$AM_PACKAGE_VERSION_PATTERN = "^\\s*\\[?([^]\\s]+)\\]?\\s*\$";
# Note that there is no AC_PATH_TOOL.  But we don't really care.
$AC_CHECK_PATTERN = "AC_(CHECK|PATH)_(PROG|PROGS|TOOL)\\(\\[?(\\w+)";
$AM_MISSING_PATTERN = "AM_MISSING_PROG\\(\\[?(\\w+)";
# Just check for alphanumeric in AC_SUBST.  If you do AC_SUBST(5),
# then too bad.
$AC_SUBST_PATTERN = "AC_SUBST\\(\\[?(\\w+)";
$AM_CONDITIONAL_PATTERN = "AM_CONDITIONAL\\((\\w+)";

# Constants to define the "strictness" level.
$FOREIGN = 0;
$GNU = 1;
$GNITS = 2;

# These constants are returned by lang_*_rewrite functions.
# LANG_SUBDIR means that the resulting object file should be in a
# subdir if the source file is.  In this case the file name cannot
# have `..' components.
$LANG_IGNORE = 0;
$LANG_PROCESS = 1;
$LANG_SUBDIR = 2;



# Variables global to entire run.

# Variables related to the options.

# TRUE if we should always generate Makefile.in.
$force_generation = 1;

# Strictness level as set on command line.
$default_strictness = $GNU;

# Name of strictness level, as set on command line.
$default_strictness_name = 'gnu';

# This is TRUE if automatic dependency generation code should be
# included in generated Makefile.in.
$cmdline_use_dependencies = 1;

# TRUE if in verbose mode.
$verbose = 0;

# This holds our (eventual) exit status.  We don't actually exit until
# we have processed all input files.
$exit_status = 0;

# From the Perl manual.
$symlink_exists = (eval 'symlink ("", "");', $@ eq '');

# TRUE if missing standard files should be installed.
$add_missing = 0;

# TRUE if we should copy missing files; otherwise symlink if possible.
$copy_missing = 0;

# TRUE if we should always update files that we know about.
$force_missing = 0;


# Variables filled during files scanning.

# Name of the top autoconf input: `configure.ac' or `configure.in'.
$configure_ac = '';

# Files found by scanning configure.ac for LIBOBJS.
%libsources = ();

# True if AM_C_PROTOTYPES appears in configure.ac.
$am_c_prototypes = 0;

# Names used in AC_CONFIG_HEADER call.  @config_fullnames holds the
# name which appears in AC_CONFIG_HEADER, colon and all.
# @config_names holds the file names.  @config_headers holds the '.in'
# files.  Ordinarily these are similar, but they can be different if
# the weird "NAME:FILE" syntax is used.
@config_fullnames = ();
@config_names = ();
@config_headers = ();
# Line number at which AC_CONFIG_HEADER appears in configure.ac.
$config_header_line = 0;

# Directory where output files go.  Actually, output files are
# relative to this directory.
$output_directory = '.';

# Relative location of top build directory.
$top_builddir = '';

# List of Makefile.am's to process, and their corresponding outputs.
@input_files = ();
%output_files = ();

# Complete list of Makefile.am's that exist.
@configure_input_files = ();

# List of files in AC_OUTPUT without Makefile.am, and their outputs.
@other_input_files = ();
# Line number at which AC_OUTPUT seen.
$ac_output_line = 0;

# List of directories to search for configure-required files.  This
# can be set by AC_CONFIG_AUX_DIR.
@config_aux_path = ('.', '..', '../..');
$config_aux_dir = '';

# Whether AC_PROG_MAKE_SET has been seen in configure.ac.
$seen_make_set = 0;

# Whether AM_GNU_GETTEXT has been seen in configure.ac.
$seen_gettext = 0;
# Line number at which AM_GNU_GETTEXT seen.
$ac_gettext_line = 0;

# Whether ALL_LINGUAS has been seen.
$seen_linguas = '';
# The actual text.
$all_linguas = '';
# Line number at which it appears.
$all_linguas_line = 0;

# 1 if AC_PROG_INSTALL seen.
$seen_prog_install = 0;

# Whether AC_PATH_XTRA has been seen in configure.ac.
$seen_path_xtra = 0;

# TRUE if AC_DECL_YYTEXT was seen.
$seen_decl_yytext = 0;

# TRUE if we've seen AC_CANONICAL_(HOST|SYSTEM).  The presence of
# AC_CHECK_TOOL also sets this.
$seen_canonical = 0;

# TRUE if we've seen AC_ARG_PROGRAM.
$seen_arg_prog = 0;

# TRUE if we've seen AC_PROG_LIBTOOL.
$seen_libtool = 0;
$libtool_line = 0;

# Files installed by libtoolize.
@libtoolize_files = ('ltmain.sh', 'config.guess', 'config.sub');
# ltconfig appears here for compatibility with old versions of libtool.
@libtoolize_sometimes = ('ltconfig', 'ltcf-c.sh', 'ltcf-cxx.sh',
			 'ltcf-gcj.sh');

# TRUE if we've seen AM_MAINTAINER_MODE.
$seen_maint_mode = 0;

# Actual version we've seen.
$package_version = '';

# Line number where we saw version definition.
$package_version_line = 0;

# TRUE if we've seen AM_PATH_LISPDIR.
$seen_lispdir = 0;

# TRUE if we've seen AM_CHECK_PYTHON.
$seen_pythondir = 0;

# TRUE if we've seen AC_EXEEXT.
$seen_exeext = 0;

# TRUE if we've seen AC_OBJEXT.
$seen_objext = 0;

# TRUE if we've seen AC_ENABLE_MULTILIB.
$seen_multilib = 0;

# TRUE if we've seen AM_PROG_CC_C_O
$seen_cc_c_o = 0;

# TRUE if we've seen AM_INIT_AUTOMAKE.
$seen_init_automake = 0;

# Hash table of discovered configure substitutions.  Keys are names,
# values are `FILE:LINE' strings which are used by error message
# generation.
%configure_vars = ();

# This is used to keep track of which variable definitions we are
# scanning.  It is only used in certain limited ways, but it has to be
# global.  It is declared just for documentation purposes.
%vars_scanned = ();

# Charsets used by maintainer and in distribution.  MAINT_CHARSET is
# handled in a funny way: if seen in the top-level Makefile.am, it is
# used for every directory which does not specify a different value.
# The rationale here is that some directories (eg gettext) might be
# distributions of other packages, and thus require their own charset
# info.  However, the DIST_CHARSET must be the same for the entire
# package; it can only be set at top-level.
# FIXME: this yields bugs when rebuilding.  What to do?  Always
# read (and sometimes discard) top-level Makefile.am?
$maint_charset = '';
$dist_charset = 'utf8';		# recode doesn't support this yet.

# Name of input file ("Makefile.in") and output file ("Makefile.am").
# These have no directory components.
$am_file_name = '';
$in_file_name = '';

# TRUE if --cygnus seen.
$cygnus_mode = 0;

# Hash table of AM_CONDITIONAL variables seen in configure.
%configure_cond = ();

# Map from obsolete macros to hints for new macros.
# If you change this, change the corresponding list in aclocal.in.
# FIXME: should just put this into a single file.
%obsolete_macros =
    (
     'AC_FEATURE_CTYPE', "use \`AC_HEADER_STDC'",
     'AC_FEATURE_ERRNO', "add \`strerror' to \`AC_REPLACE_FUNCS(...)'",
     'AC_FEATURE_EXIT', '',
     'AC_SYSTEM_HEADER', '',

     # Note that we do not handle this one, because it is still run
     # from AM_CONFIG_HEADER.  So we deal with it specially in
     # &scan_autoconf_files.
     # 'AC_CONFIG_HEADER', "use \`AM_CONFIG_HEADER'",

     'fp_C_PROTOTYPES', "use \`AM_C_PROTOTYPES'",
     'fp_PROG_CC_STDC', "use \`AM_PROG_CC_STDC'",
     'fp_PROG_INSTALL', "use \`AC_PROG_INSTALL'",
     'fp_WITH_DMALLOC', "use \`AM_WITH_DMALLOC'",
     'fp_WITH_REGEX', "use \`AM_WITH_REGEX'",
     'gm_PROG_LIBTOOL', "use \`AM_PROG_LIBTOOL'",
     'jm_MAINTAINER_MODE', "use \`AM_MAINTAINER_MODE'",
     'md_TYPE_PTRDIFF_T', "use \`AM_TYPE_PTRDIFF_T'",
     'ud_PATH_LISPDIR', "use \`AM_PATH_LISPDIR'",
     'ud_GNU_GETTEXT', "use \`AM_GNU_GETTEXT'",

     # Now part of autoconf proper, under a different name.
     'AM_FUNC_FNMATCH', "use \`AC_FUNC_FNMATCH'",
     'fp_FUNC_FNMATCH', "use \`AC_FUNC_FNMATCH'",
     'AM_SANITY_CHECK_CC', "automatically done by \`AC_PROG_CC'",
     'AM_PROG_INSTALL', "use \`AC_PROG_INSTALL'",
     'AM_EXEEXT', "use \`AC_EXEEXT'",
     'AM_CYGWIN32', "use \`AC_CYGWIN'",
     'AM_MINGW32', "use \`AC_MINGW32'",
     'AM_FUNC_MKTIME', "use \`AC_FUNC_MKTIME'",

# These aren't quite obsolete.
#      'md_PATH_PROG',
     );

# Regexp to match the above macros.
$obsolete_rx = '(\b' . join ('\b|\b', keys %obsolete_macros) . '\b)';

# This maps extensions onto language names.
%extension_map = ();

# This maps languages names onto properties.
%language_map = ();

# This holds all the files that would go in `dist_common' which we
# discovered while scanning configure.ac.  We might distribute these
# in the top-level Makefile.in.
%configure_dist_common = ();


# Initialize global constants and our list of languages that are
# internally supported.
&initialize_global_constants;

&register_language ('c', 'ansi-p=1', 'autodep=', 'flags=CFLAGS',
		    'compile=$(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)',
		    'compiler-name=COMPILE',
		    'output-arg=-c',
		    'c');
&register_language ('cxx', 'linker=CXXLINK', 'autodep=CXX', 'flags=CXXFLAGS',
		    'compile=$(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)',
		    'compiler-name=CXXCOMPILE',
		    'output-arg=-c -o $@',
		    'c++', 'cc', 'cpp', 'cxx', 'C');
&register_language ('objc', 'linker=OBJCLINK', 'autodep=OBJC',
		    'flags=OBJCFLAGS',
		    'compile=$(OBJC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_OBJCFLAGS) $(OBJCFLAGS)',
		    'compiler-name=OBJCCOMPILE',
		    'output-arg=-c -o $@',
                    'm');
&register_language ('header',
		    'h', 'H', 'hxx', 'h++', 'hh', 'hpp', 'inc');

# For now, yacc and lex can't be handled on a per-exe basis.
&register_language ('yacc', 'ansi-p=1', 'derived-autodep=yes',
		    'y');
&register_language ('yaccxx', 'linker=CXXLINK', 'derived-autodep=yes',
		    'y++', 'yy', 'yxx', 'ypp');
&register_language ('lex', 'ansi-p=1', 'derived-autodep=yes',
		    'l');
&register_language ('lexxx', 'linker=CXXLINK', 'derived-autodep=yes',
		    'l++', 'll', 'lxx', 'lpp');

&register_language ('asm',
		    'flags=CFLAGS', # FIXME: asmflags?
		    'compile=$(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)', # FIXME: a different compiler?
		    'compiler-name=COMPILE',
		    'output-arg=-c',
		    's', 'S');

&register_language ('f77', 'linker=F77LINK', 'flags=FFLAGS',
		    'compile=$(F77) $(AM_FFLAGS) $(FFLAGS)',
		    'compiler-name=F77COMPILE',
		    'output-arg=-c -o $@',
		    'f', 'for', 'f90');
&register_language ('ppf77', 'linker=F77LINK', 'flags=FFLAGS',
		    'compile=$(F77) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_FFLAGS) $(FFLAGS)',
		    'compiler-name=PPF77COMPILE',
		    'output-arg=-c -o $@',
		    'F');
&register_language ('ratfor', 'linker=F77LINK',
		    'flags=RFLAGS', # FIXME also FFLAGS.
		    'compile=$(F77) $(AM_FFLAGS) $(FFLAGS) $(AM_RFLAGS) $(RFLAGS)',
		    'compiler-name=RCOMPILE',
		    'output-arg=-c -o $@',
		    'r');
# FIXME: for now we can't do dependency tracking for Java.
# autodep=GCJ
&register_language ('java', 'linker=GCJLINK', 'flags=GCJFLAGS',
		    'compile=$(GCJ) $(DEFS) $(INCLUDES) $(AM_GCJFLAGS) $(GCJFLAGS)',
		    'compiler-name=GCJCOMPILE',
		    'output-arg=-c -o $@',
		    'java', 'class', 'zip', 'jar');


# Parse command line.
&parse_arguments (@ARGV);

# Do configure.ac scan only once.
&scan_autoconf_files;

die "automake: no \`Makefile.am' found or specified\n"
    if ! @input_files;

# Now do all the work on each file.
foreach $am_file (@input_files)
{
    if (! -f ($am_file . '.am'))
    {
	&am_error ("\`" . $am_file . ".am' does not exist");
    }
    else
    {
 	&generate_makefile ($output_files{$am_file}, $am_file);
    }
}

&am_conf_error ("AC_PROG_INSTALL must be used")
    if (! $seen_prog_install);

exit $exit_status;


################################################################


# prog_error (@PRINT-ME)
# ----------------------
# Signal a programming error, display PRINT-ME, and exit 1.
sub prog_error
{
    print STDERR "automake: programming error: @_\n";
    exit 1;
}


################################################################

# Parse command line.
sub parse_arguments
{
    local (@arglist) = @_;

    # Start off as gnu.
    &set_strictness ('gnu');

    while (@arglist)
    {
	if ($arglist[0] eq "--version")
	{
	    print "automake (GNU $PACKAGE) $VERSION\n\n";
	    print "Copyright 2000 Free Software Foundation, Inc.\n";
	    print "This is free software; see the source for copying conditions.  There is NO\n";
	    print "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n";
	    print "Written by Tom Tromey <tromey\@cygnus.com>\n";

	    exit 0;
	}
	elsif ($arglist[0] eq "--help")
	{
	    &usage;
	}
	elsif ($arglist[0] =~ /^--amdir=(.+)$/)
	{
	    $am_dir = $1;
	}
	elsif ($arglist[0] eq '--amdir')
	{
	    &require_argument (@arglist);
	    shift (@arglist);
	    $am_dir = $arglist[0];
	}
	elsif ($arglist[0] eq '--gnu')
	{
	    &set_strictness ('gnu');
	}
	elsif ($arglist[0] eq '--gnits')
	{
	    &set_strictness ('gnits');
	}
	elsif ($arglist[0] eq '--cygnus')
	{
	    $cygnus_mode = 1;
	}
	elsif ($arglist[0] eq '--foreign')
	{
	    &set_strictness ('foreign');
	}
	elsif ($arglist[0] eq '--include-deps')
	{
	    $cmdline_use_dependencies = 1;
	}
	elsif ($arglist[0] eq '--ignore-deps' || $arglist[0] eq '-i')
	{
	    $cmdline_use_dependencies = 0;
	}
	elsif ($arglist[0] eq '--no-force')
	{
	    $force_generation = 0;
	}
	elsif ($arglist[0] eq '--force-missing')
	{
	    $force_missing = 1;
	}
	elsif ($arglist[0] =~ /^--output-dir=(.*)$/)
	{
	    # Set output directory.
	    $output_directory = $1;
	}
	elsif ($arglist[0] eq '--output-dir' || $arglist[0] eq '-o')
	{
	    &require_argument (@arglist);
	    shift (@arglist);
	    $output_directory = $arglist[0];
	}
	elsif ($arglist[0] eq '--add-missing' || $arglist[0] eq '-a')
	{
	    $add_missing = 1;
	}
	elsif ($arglist[0] eq '--copy' || $arglist[0] eq '-c')
	{
	    $copy_missing = 1;
	}
	elsif ($arglist[0] eq '--verbose' || $arglist[0] eq '-v')
	{
	    $verbose = 1;
	}
	elsif ($arglist[0] eq '--')
	{
	    # Stop option processing.
	    shift (@arglist);
	    push (@input_files, @arglist);
	    last;
	}
	elsif ($arglist[0] =~ /^-/)
	{
	    die "automake: unrecognized option -- \`$arglist[0]'\nTry \`automake --help' for more information.\n";
	}
	else
	{
	    # Handle $local:$input syntax.  Note that we only examine
	    # the first ":" file to see if it is automake input; the
	    # rest are just taken verbatim.  We still keep all the
	    # files around for dependency checking, however.
	    local ($local, $input, @rest) = split (/:/, $arglist[0]);
	    if (! $input)
	    {
		$input = $local;
	    }
	    else
	    {
		# Strip .in; later on .am is tacked on.  That is how
		# the automake input file is found.  Maybe not the
		# best way, but it is easy to explain.  FIXME: should
		# be error if .in is missing.
		$input =~ s/\.in$//;
	    }
	    push (@input_files, $input);
	    $output_files{$input} = join (':', ($local, @rest));
	}

	shift (@arglist);
    }

    # Take global strictness from whatever we currently have set.
    $default_strictness = $strictness;
    $default_strictness_name = $strictness_name;
}

# Ensure argument exists, or die.
sub require_argument
{
    local ($arg, @arglist) = @_;
    die "automake: no argument given for option \`$arg'\n"
	if ! @arglist;
}

################################################################

# Generate a Makefile.in given the name of the corresponding Makefile and
# the name of the file output by config.status.
sub generate_makefile
{
    local ($output, $makefile) = @_;

    ($am_file_name = $makefile) =~ s/^.*\///;
    $in_file_name = $am_file_name . '.in';
    $am_file_name .= '.am';

    # $OUTPUT is encoded.  If it contains a ":" then the first element
    # is the real output file, and all remaining elements are input
    # files.  We don't scan or otherwise deal with these input file,
    # other than to mark them as dependencies.  See
    # &scan_autoconf_files for details.
    local (@secondary_inputs);
    ($output, @secondary_inputs) = split (/:/, $output);

    &initialize_per_input;
    $relative_dir = &dirname ($output);
    $am_relative_dir = &dirname ($makefile);

    # At the toplevel directory, we might need config.guess, config.sub
    # or libtool scripts (ltconfig and ltmain.sh).
    if ($relative_dir eq '.')
    {
 	# libtool requires some files.
 	&require_conf_file_with_conf_line ($libtool_line, $FOREIGN,
 					   @libtoolize_files)
	    if $seen_libtool;

        # AC_CANONICAL_HOST and AC_CANONICAL_SYSTEM need config.guess and
        # config.sub.
        &require_config_file ($FOREIGN, 'config.guess', 'config.sub')
	    if $seen_canonical;
    }

    # We still need Makefile.in here, because sometimes the `dist'
    # target doesn't re-run automake.
    if ($am_relative_dir eq $relative_dir)
    {
	# Only distribute the files if they are in the same subdir as
	# the generated makefile.
	&push_dist_common ($in_file_name, $am_file_name);
    }

    push (@sources, '$(SOURCES)')
	if &variable_defined ('SOURCES');
    push (@objects, '$(OBJECTS)')
	if &variable_defined ('OBJECTS');

    &read_main_am_file ($makefile . '.am');
    if (&handle_options)
    {
	# Fatal error.  Just return, so we can continue with next file.
	return;
    }

    # Must do this after reading .am file.  See read_main_am_file to
    # understand weird tricks we play there with variables.
    &define_variable ('subdir', $relative_dir);

    # Check first, because we might modify some state.
    &check_cygnus;
    &check_gnu_standards;
    &check_gnits_standards;

    &handle_configure ($output, $makefile, @secondary_inputs);
    &handle_gettext;
    &handle_libraries;
    &handle_ltlibraries;
    &handle_programs;
    &handle_scripts;

    # This must be run after all the sources are scanned.
    &finish_languages;

    # Re-init SOURCES and OBJECTS.  FIXME: other code shouldn't depend
    # on this (but currently does).
    $contents{'SOURCES'} = join (' ', @sources);
    $contents{'OBJECTS'} = join (' ', @objects);
    &define_pretty_variable ('DIST_SOURCES', '', @dist_sources);

    &handle_multilib;
    &handle_texinfo;
    &handle_emacs_lisp;
    &handle_python;
    &handle_java;
    &handle_man_pages;
    &handle_data;
    &handle_headers;
    &handle_subdirs;
    &handle_tags;
    &handle_minor_options;
    &handle_dependencies;
    &handle_tests;

    # This must come after most other rules.
    &handle_dist ($makefile);

    &handle_footer;
    &handle_merge_targets ($output);
    &handle_installdirs;
    &handle_clean;
    &handle_factored_dependencies;

    &check_typos;

    if (! -d ($output_directory . '/' . $am_relative_dir))
    {
	mkdir ($output_directory . '/' . $am_relative_dir, 0755);
    }

    local ($out_file) = $output_directory . '/' . $makefile . ".in";
    if (! $force_generation && -e $out_file)
    {
	local ($am_time) = (stat ($makefile . '.am'))[9];
	local ($in_time) = (stat ($out_file))[9];
	# FIXME: should cache these times.
	local ($conf_time) = (stat ($configure_ac))[9];
	# FIXME: how to do unsigned comparison?
	if ($am_time < $in_time || $am_time < $conf_time)
	{
	    # No need to update.
	    return;
	}
	if (-f 'aclocal.m4')
	{
	    local ($acl_time) = (stat _)[9];
	    return if ($am_time < $acl_time);
	}
    }

    if (! open (GM_FILE, "> " . $out_file))
    {
	warn "automake: ${am_file}.in: cannot write: $!\n";
	$exit_status = 1;
	return;
    }
    print "automake: creating ", $makefile, ".in\n" if $verbose;

    # In case we're running under MSWindows, don't write with CRLF
    # (as it causes problems for the dependency-file extraction in
    # AM_OUTPUT_DEPENDENCY_COMMANDS).
    binmode GM_FILE;

    print GM_FILE $output_vars;
    # We make sure that `all:' is the first target.
    print GM_FILE $output_all;
    print GM_FILE $output_header;
    print GM_FILE $output_rules;
    print GM_FILE $output_trailer;

    if (! close (GM_FILE))
      {
	warn "automake: $am_file.in: cannot close: $!\n";
	$exit_status = 1;
	return;
      }
}

################################################################

# Handle AUTOMAKE_OPTIONS variable.  Return 1 on error, 0 otherwise.
sub handle_options
{
    if (&variable_defined ('AUTOMAKE_OPTIONS'))
    {
	foreach (&variable_value_as_list ('AUTOMAKE_OPTIONS', ''))
	{
	    $options{$_} = 1;
	    if ($_ eq 'gnits' || $_ eq 'gnu' || $_ eq 'foreign')
	    {
		&set_strictness ($_);
	    }
	    elsif ($_ eq 'cygnus')
	    {
		$cygnus_mode = 1;
	    }
	    elsif (/ansi2knr/)
	    {
		# An option like "../lib/ansi2knr" is allowed.  With
		# no path prefix, we assume the required programs are
		# in this directory.  We save the actual option for
		# later.
		$options{'ansi2knr'} = $_;
	    }
	    elsif ($_ eq 'no-installman' || $_ eq 'no-installinfo'
		   || $_ eq 'dist-shar' || $_ eq 'dist-zip'
		   || $_ eq 'dist-tarZ' || $_ eq 'dist-bzip2'
		   || $_ eq 'dejagnu' || $_ eq 'no-texinfo.tex'
		   || $_ eq 'readme-alpha' || $_ eq 'check-news'
		   || $_ eq 'subdir-objects' || $_ eq 'nostdinc')
	    {
		# Explicitly recognize these.
	    }
	    elsif ($_ eq 'no-dependencies')
	    {
		$use_dependencies = 0;
	    }
	    elsif (/([0-9]+)\.([0-9]+)([a-z])?/)
	    {
		# Got a version number.

		local ($rmajor, $rminor, $ralpha) = ($1, $2, $3);

		&prog_error ("version is incorrect: $VERSION")
		    if $VERSION !~ /([0-9]+)\.([0-9]+)([a-z])?/;

		local ($tmajor, $tminor, $talpha) = ($1, $2, $3);

		# 2.0 is better than 1.0.
		# 1.2 is better than 1.1.
		# 1.2a is better than 1.2.
		if ($rmajor > $tmajor
		    || ($rmajor == $tmajor && $rminor > $tminor)
		    || ($rminor == $tminor && $rminor == $tminor
			&& $ralpha gt $talpha))
		{
		    &am_line_error ('AUTOMAKE_OPTIONS',
				    "require version $_, only have $VERSION");
		    return 1;
		}
	    }
	    else
	    {
		&am_line_error ('AUTOMAKE_OPTIONS',
				"option \`" . $_ . "\' not recognized");
	    }
	}
    }

    if ($strictness == $GNITS)
    {
	$options{'readme-alpha'} = 1;
	$options{'check-news'} = 1;
    }

    return 0;
}


# get_object_extension ($OUT)
# ---------------------------
# Return object extension.  Just once, put some code into the output.
# OUT is the name of the output file
sub get_object_extension
{
    local ($out) = @_;

    # Maybe require libtool library object files.
    local ($extension) = '.o';
    $extension = '.$(OBJEXT)' if $seen_objext;
    $extension = '.lo' if ($out =~ /\.la$/);

    if (! $included_generic_compile)
    {
	# Boilerplate.
	local ($default_include) = '';
	if (! defined $options{'nostdinc'})
	{
	    $default_include = ' -I. -I$(srcdir)';

	    if (&variable_defined ('CONFIG_HEADER'))
	    {
		local ($one_hdr);
		foreach $one_hdr (split (' ',
					 &variable_value ('CONFIG_HEADER')))
		{
		    $default_include .= ' -I' . &dirname ($one_hdr);
		}
	    }
	}
	local ($xform) = &transform ('DEFAULT_INCLUDES' => $default_include);
	$output_vars .= &file_contents ('comp-vars', $xform);

	$xform = $seen_objext ? 's/^OBJEXT//;' : 's/^OBJEXT.*$//;';
	$output_rules .= &file_contents ('compile', $xform);

	&push_phony_cleaners ('compile');

	# If using X, include some extra variable definitions.  NOTE
	# we don't want to force these into CFLAGS or anything,
	# because not all programs will necessarily use X.
	if ($seen_path_xtra)
	{
	    local ($var);
	    foreach $var ('X_CFLAGS', 'X_LIBS', 'X_EXTRA_LIBS', 'X_PRE_LIBS')
	    {
		&define_configure_variable ($var);
	    }
	}

	push (@suffixes, '.c', '.o');
	push (@suffixes, '.obj') if $seen_objext;
	&depend ('clean', 'compile');

	$included_generic_compile = 1;
    }

    if ($seen_libtool && ! $included_libtool_compile)
    {
	# Output the libtool compilation rules.
	$output_rules .= &file_contents ('libtool');

	&push_phony_cleaners ('libtool');

	push (@suffixes, '.lo');
	&depend ('clean', 'libtool');

	$included_libtool_compile = 1;
    }

    # Check for automatic de-ANSI-fication.
    if (defined $options{'ansi2knr'})
    {
	$extension = '$U' . $extension;
	if (! $included_knr_compile)
	{
	    if (! $am_c_prototypes)
	    {
		&am_line_error ('AUTOMAKE_OPTIONS',
				"option \`ansi2knr' in use but \`AM_C_PROTOTYPES' not in \`$configure_ac'");
		&keyed_aclocal_warning ('AM_C_PROTOTYPES');
		# Only give this error once.
		$am_c_prototypes = 1;
	    }

	    # Only require ansi2knr files if they should appear in
	    # this directory.
	    if ($options{'ansi2knr'} eq 'ansi2knr')
	    {
		&require_file_with_line ('AUTOMAKE_OPTIONS', $FOREIGN,
					 'ansi2knr.c', 'ansi2knr.1');
		$output_rules .= &file_contents ('kr-extra');
		&depend ('clean', 'krextra');
		&push_phony_cleaners ('krextra');
	    }

	    # Generate rules to build ansi2knr.  If it is in some
	    # other directory, then generate dependencies but have the
	    # rule just run elsewhere.
	    $objext = $seen_objext ? ".\$(OBJEXT)" : ".o";
	    $output_rules .= ($options{'ansi2knr'} . ': '
			      . $options{'ansi2knr'} . $objext . "\n");
	    if ($options{'ansi2knr'} eq 'ansi2knr')
	    {
		$output_rules .= ("\t\$(LINK) ansi2knr" . $objext
				  . " \$(LIBS)\n"
				  . "ansi2knr" . $objext
				  . ": \$(CONFIG_HEADER)\n\n");
	    }
	    else
	    {
		$output_rules .= ("\tcd " . &dirname ($options{'ansi2knr'})
				  . " && \$(MAKE) \$(AM_MAKEFLAGS) "
				  . "ansi2knr\n\n");
		# This is required for non-GNU makes.
	        $output_rules .= ($options{'ansi2knr'} . $objext . ":\n");
		$output_rules .= ("\tcd " . &dirname ($options{'ansi2knr'})
				  . " && \$(MAKE) \$(AM_MAKEFLAGS)"
				  . " ansi2knr" . $objext . "\n\n");
	    }

	    # Make sure ansi2knr can be found: if no path specified,
	    # specify "./".
	    if ($options{'ansi2knr'} eq 'ansi2knr')
	    {
		# Substitution from AM_C_PROTOTYPES.  This makes it be
		# built only when necessary.
		&define_configure_variable ('ANSI2KNR');
		# ansi2knr needs to be built before subdirs, so unshift it.
		unshift (@all, '$(ANSI2KNR)');
	    }
	    else
	    {
		# Found in another directory.
		&define_variable ("ANSI2KNR", $options{'ansi2knr'});
	    }

	    $output_rules .= &file_contents ('clean-kr');

	    &depend ('clean', 'kr');
	    &push_phony_cleaners ('kr');

	    $included_knr_compile = 1;
	}
    }

    return $extension;
}

# Call finish function for each language that was used.
sub finish_languages
{
    local ($ltcompile, $ltlink) = &libtool_compiler;

    local ($ext, $name, $lang, %done);
    local ($non_c) = 1;
    foreach $ext (sort keys %extension_seen)
    {
	$lang = $extension_map{$ext};

	# Generate the appropriate rules for this extension.  If
	# dependency tracking was requested, and this extension
	# supports it, then we don't generate the rule here.
	local ($comp) = '';

	if ($use_dependencies && $language_map{$lang . '-autodep'} ne 'no')
	{
	    # Don't generate the rule, but still generate the variables.
	    if (defined $language_map{$lang . '-compile'})
	    {
		$comp = $language_map{$lang . '-compile'};
	    }
	}
	elsif (defined $language_map{$lang . '-compile'})
	{
	    $comp = $language_map{$lang . '-compile'};

	    local ($outarg) = $language_map{$lang . '-output-arg'};
	    if ($language_map{$lang . '-flags'} eq 'CFLAGS')
	    {
		# C compilers don't always support -c -o.
		if (defined $options{'subdir-objects'})
		{
		    $outarg .= ' -o $@';
		}
	    }

	    local ($full) = ("\t\$("
			     . $language_map{$lang . '-compiler-name'}
			     . ") "
			     . $outarg);
	    $output_rules .= (".$ext.o:\n"
			      . $full
			      . " \$<\n");
	    # FIXME: Using cygpath should be somehow conditional.
	    $output_rules .= (".$ext.obj:\n"
			      . $full
			      . " \`cygpath -w \$<\`\n")
		if $seen_objext;
	    $output_rules .= (".$ext.lo:\n"
			      . "\t\$(LT"
			      . $language_map{$lang . '-compiler-name'}
			      . ") "
			      . $language_map{$lang . '-output-arg'}
			      # We can always use -c -o with libtool.
			      . ($language_map{$lang . '-flags'} eq 'CFLAGS'
				 ? ' -o $@' : '')
			      . " \$<\n")
		if $seen_libtool;
	}

	push (@suffixes, '.' . $ext);

	# The rest of the loop is done once per language.
	next if defined $done{$lang};
	$done{$lang} = 1;

	$non_c = 0 if $lang !~ /(objc|cxx|f77|ratfor)$/;

	if ($comp ne '')
	{
	    &define_compiler_variable ($language_map{$lang . '-compiler-name'},
				       $ltcompile, $comp);
	}
	# The compiler's flag must be a configure variable.
	if (defined $language_map{$lang . '-flags'})
	{
	    &define_configure_variable ($language_map{$lang . '-flags'});
	}

	# Compute the function name of the finisher and then call it.
	$name = 'lang_' . $lang . '_finish';
	& $name ();
    }

    # If the project is entirely C++ or entirely Fortran 77, don't
    # bother with the C stuff.  But if anything else creeps in, then use
    # it.
    if ($need_link || ! $non_c || scalar keys %suffix_rules > 0)
    {
	if (! defined $done{'c'})
	{
	    &define_configure_variable ($language_map{'c-flags'});
	    &define_compiler_variable ($language_map{'c-compiler-name'},
				       $ltcompile,
				       $language_map{'c-compile'});
	}
	&define_variable ('CCLD', '$(CC)');
	&define_variable ('LINK', $ltlink . '$(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@');
    }
}

# Output a rule to build from a YACC source.  The output from YACC is
# compiled with C or C++, depending on the extension of the YACC file.
sub output_yacc_build_rule
{
    local ($yacc_suffix, $use_ylwrap, $c_suffix) = @_;

    local ($suffix);
    ($suffix = $yacc_suffix) =~ tr/y/c/;
    push (@suffixes, $yacc_suffix, $suffix);

    # Generate rule for c/c++.
    $output_rules .= "$yacc_suffix$suffix:\n\t";

    if ($use_ylwrap)
    {
	$output_rules .= ('$(SHELL) $(YLWRAP)'
			  . ' "$(YACC)" $< y.tab.c $*' . $suffix
			  . ' y.tab.h $*.h -- $(AM_YFLAGS) $(YFLAGS)');
    }
    else
    {
	$output_rules .= ('$(YACC) $(AM_YFLAGS) $(YFLAGS) $< && mv y.tab.c $*'
			  . $suffix . "\n"
			  . "\tif test -f y.tab.h; then \\\n"
			  . "\tif cmp -s y.tab.h \$*.h; then rm -f y.tab.h; else mv y.tab.h \$*.h; fi; \\\n"
			  . "\telse :; fi");
    }
    $output_rules .= "\n";
}

sub output_lex_build_rule
{
    local ($lex_suffix, $use_ylwrap) = @_;
    local ($c_suffix);

    ($c_suffix = $lex_suffix) =~ tr/l/c/;
    push (@suffixes, $lex_suffix);
    &define_configure_variable ('LEX_OUTPUT_ROOT');
    &define_configure_variable ('LEXLIB');
    $output_rules .= "$lex_suffix$c_suffix:\n\t";

    if ($use_ylwrap)
    {
        # Is the $@ correct here?  If so, why not use it in the ylwrap
        # build rule for yacc above?
	$output_rules .= '$(SHELL) $(YLWRAP)'
	    . ' "$(LEX)" $< $(LEX_OUTPUT_ROOT).c $@ -- $(AM_LFLAGS) $(LFLAGS)';
    }
    else
    {
	$output_rules .= '$(LEX) $(AM_LFLAGS) $(LFLAGS) $< && mv $(LEX_OUTPUT_ROOT).c $@';
    }
    $output_rules .= "\n";
}


# Check to make sure a source defined in LIBOBJS is not explicitly
# mentioned.  This is a separate function (as opposed to being inlined
# in handle_source_transform) because it isn't always appropriate to
# do this check.
sub check_libobjs_sources
{
    local ($one_file, $unxformed) = @_;

    local ($prefix, $file, @files);
    foreach $prefix ('', 'EXTRA_', 'dist_', 'nodist_',
		     'dist_EXTRA_', 'nodist_EXTRA_')
    {
	if (&variable_defined ($prefix . $one_file . '_SOURCES'))
	{
	    @files = &variable_value_as_list (($prefix
					       . $one_file . '_SOURCES'),
					      'all');
	}
	elsif ($prefix eq '')
	{
	    @files = ($unxformed . '.c');
	}
	else
	{
	    next;
	}

	foreach $file (@files)
	{
	    if (defined $libsources{$file})
	    {
		&am_line_error ($prefix . $one_file . '_SOURCES',
				"automatically discovered file \`$file' should not be explicitly mentioned");
	    }
	}
    }
}


# ($LINKER, @OBJECTS)
# handle_single_transform_list ($VAR, $DERIVED, $OBJ, @FILES)
# -----------------------------------------------------------
# Does much of the actual work for handle_source_transform.
# Arguments are:
#   $DERIVED is the name of resulting executable or library
#   $OBJ is the object extension (e.g., `$U.lo')
#   @FILES is the list of source files to transform
# Result is a list
#   $LINKER is name of linker to use (empty string for default linker)
#   @OBJECTS are names of objects
sub handle_single_transform_list
{
    local ($var, $derived, $obj, @files) = @_;
    local (@result) = ();
    local ($nonansi_obj) = $obj;
    $nonansi_obj =~ s/\$U//g;
    local (%linkers_used) = ();

    # Turn sources into objects.
    foreach (@files)
    {
        # Configure substitutions in _SOURCES variables are errors.
        if (/^\@.*\@$/)
        {
            &am_line_error ($var, "$var includes configure substitution \`$_'");
            next;
        }

        # If the source file is in a subdirectory then the `.o' is
        # put into the current directory.

        # Split file name into base and extension.
        local ($full, $directory, $base, $extension, $linker, $object);
        next if ! /^((.*)\/)?([^\/]*)\.(.*)$/;
        $full = $_;
        $directory = $2;
        $base = $3;
        $extension = $4;

        local ($xbase) = $base;

        # We must generate a rule for the object if it requires
        # its own flags.
        local ($rule) = '';
        local ($renamed) = 0;

        $extension = &derive_suffix ($extension);
        local ($lang) = $extension_map{$extension};
        if ($lang)
        {
            &saw_extension ($extension);
            # Found the language, so see what it says.
            local ($subr) = 'lang_' . $lang . '_rewrite';
            # Note: computed subr call.
            local ($r) = & $subr ($directory, $base, $extension);
            # Skip this entry if we were asked not to process it.
            next if $r == $LANG_IGNORE;

            # Now extract linker and other info.
            $linker = $language_map{$lang . '-linker'};

            local ($this_obj_ext);
            if ($language_map{$lang . '-ansi-p'})
            {
                $object = $base . $obj;
                $this_obj_ext = $obj;
            }
            else
            {
                $object = $base . $nonansi_obj;
                $this_obj_ext = $nonansi_obj;
            }

            if ($language_map{$lang . '-flags'} ne ''
                && &variable_defined ($derived . '_'
                                      . $language_map{$lang . '-flags'}))
            {
                # We have a per-executable flag in effect for this
                # object.  In this case we rewrite the object's
                # name to ensure it is unique.  We also require
                # the `compile' program to deal with compilers
                # where `-c -o' does not work.

                # We choose the name `DERIVED-OBJECT' to ensure
                # (1) uniqueness, and (2) continuity between
                # invocations.  However, this will result in a
                # name that is too long for losing systems, in
                # some situations.  So we provide _SHORTNAME to
                # override.

                local ($dname) = $derived;
                if (&variable_defined ($derived . '_SHORTNAME'))
                {
                    # FIXME: should use the same conditional as
                    # the _SOURCES variable.  But this is really
                    # silly overkill -- nobody should have
                    # conditional shortnames.
                    $dname = &variable_value ($derived . '_SHORTNAME');
                }
                $object = $dname . '-' . $object;

                &require_file ($FOREIGN, 'compile')
                    if $lang eq 'c';

                &prog_error ("$lang flags defined without compiler")
  		    if ! defined $language_map{$lang . '-compile'};

                # Compute the rule to compile this object.
                local ($flag) = $language_map{$lang . '-flags'};
                local ($val) = "(${derived}_${flag}";
                ($rule = $language_map{$lang . '-compile'}) =~
                    s/\(AM_$flag/$val/;

                $rule .= ' ' . $language_map{$lang . '-output-arg'};
                # For C we have to add the -o, because the
                # standard rule doesn't include it.
                if ($language_map{$lang . '-flags'} eq 'CFLAGS')
                {
                    $rule .= ' -o $@';
                }

                $renamed = 1;
            }

            # If rewrite said it was ok, put the object into a
            # subdir.
            if ($r == $LANG_SUBDIR && $directory ne '')
            {
                $object = $directory . '/' . $object;
                $xbase = $directory . '/' . $base;
            }

            # If doing dependency tracking, then we can't print
            # the rule.  If we have a subdir object, we need to
            # generate an explicit rule.  Actually, in any case
            # where the object is not in `.' we need a special
            # rule.  The per-object rules in this case are
            # generated later, by add_depend2.
            if (($use_dependencies
                 && $rule ne ''
                 && $language_map{$lang . '-autodep'} ne 'no')
                || $directory ne '')
            {
                $rule = '';
                local ($obj_sans_ext) = substr ($object, 0,
                                                - length ($this_obj_ext));
                $lang_specific_files{$lang} .= (' ' . $derived
                                                . ' ' . $full
                                                . ' ' . $obj_sans_ext);
            }
        }
        elsif ($extension eq 'o')
        {
            # This is probably the result of a direct suffix rule.
            # In this case we just accept the rewrite.  FIXME:
            # this fails if we want libtool objects.
            $object = $base . '.' . $extension;
            $linker = '';
        }
        else
        {
            # No error message here.  Used to have one, but it was
            # very unpopular.
            next;
        }

        $linkers_used{$linker} = 1;

        push (@result, $object);

        if (defined $object_map{$object})
        {
            if ($object_map{$object} ne $full)
            {
                &am_error ("object \`$object' created by \`$full' and \`$object_map{$object}'");
            }
        }
        else
        {
            local (@dep_list) = ();
            $object_map{$object} = $full;

            # If file is in subdirectory, we need explicit
            # dependency.
            if ($directory ne '' || $renamed)
            {
                push (@dep_list, $full);
            }

            # If resulting object is in subdir, we need to make
            # sure the subdir exists at build time.
            if ($object =~ /\//)
            {
                # FIXME: check that $DIRECTORY is somewhere in the
                # project

                # We don't allow `..' in object file names for
                # *any* source, not just Java.  For Java it just
                # doesn't make sense, but in general it is
                # a problem because we can't pick a good name for
                # the .deps entry.
                if ($object =~ /(\/|^)\.\.\//)
                {
                    &am_error ("\`$full' contains \`..' component but should not");
                }

                push (@dep_list, $directory . '/.dirstamp');

                # If we're generating dependencies, we also want
                # to make sure that the appropriate subdir of the
                # .deps directory is created.
                if ($use_dependencies)
                {
                    push (@dep_list, '.deps/' . $directory . '/.dirstamp');
                }

                if (! defined $directory_map{$directory})
                {
                    $directory_map{$directory} = 1;
                    $output_rules .= ($directory . "/.dirstamp:\n"
                                      . "\t\@\$(mkinstalldirs) $directory\n"
                                      . "\t\@: > $directory/.dirstamp\n");
                    if ($use_dependencies)
                    {
                        $output_rules .= ('.deps/' . $directory
                                          . "/.dirstamp:\n"
                                          . "\t\@\$(mkinstalldirs) .deps/$directory\n"
                                          . "\t\@: > .deps/$directory/.dirstamp\n");
                    }
                }
            }

            &pretty_print_rule ($object . ':', "\t", @dep_list)
                if scalar @dep_list > 0 || $rule ne '';

            # Print the rule if we have one.
            if ($rule ne '')
            {
                # Turn `$@' into name of our object file.
                local ($xform);
                ($xform = $object) =~ s,/,\\/,g;
                $rule =~ s/\$\@/$xform/;

                # We cannot use $< here since this is an explicit
                # rule and not all makes handle that.
                $rule .= " \`test -f $full || echo '\$(srcdir)/'\`$full";

                # FIXME: handle .lo and .obj as well.
                $output_rules .= "\t" . $rule . "\n";
            }
        }

        # Transform .o or $o file into .P file (for automatic
        # dependency code).
        if ($lang
            && ($language_map{$lang . '-autodep'} ne 'no'
                || $language_map{$lang . '-derived-autodep'} eq 'yes'))
        {
            local ($depfile) = $object;
            $depfile =~ s/\.([^.]*)$/.P$1/;
            $depfile =~ s/\$\(OBJEXT\)$/o/ if $seen_objext;
            $dep_files{'$(DEPDIR)/' . $depfile} = 1;
        }
    }

    return (&resolve_linker (%linkers_used), @result);
}



# Handle SOURCE->OBJECT transform for one program or library.
# Arguments are:
#   canonical (transformed) name of object to build
#   actual name of object to build
#   object extension (ie either `.o' or `$o'.
# Return result is name of linker variable that must be used.
# Empty return means just use `LINK'.
sub handle_source_transform
{
    # one_file is canonical name.  unxformed is given name.  obj is
    # object extension.
    local ($one_file, $unxformed, $obj) = @_;

    local ($linker) = '';

    if (&variable_defined ($one_file . "_OBJECTS"))
    {
	&am_line_error ($one_file . '_OBJECTS',
			$one_file . '_OBJECTS', 'should not be defined');
	# No point in continuing.
	return;
    }

    local (@files, @result, $prefix, $temp, $xpfx);
    local (%used_pfx) = ();
    foreach $prefix ('', 'EXTRA_', 'dist_', 'nodist_',
		     'dist_EXTRA_', 'nodist_EXTRA_')
    {
	# We are going to define _OBJECTS variables using the prefix.
	# Then we glom them all together.  So we can't use the null
	# prefix here as we need it later.
	$xpfx = ($prefix eq '') ? 'am_' : $prefix;

	@files = ();
	local ($var) = $prefix . $one_file . "_SOURCES";
	if (&variable_defined ($var))
	{
	    # Keep track of which prefixes we saw.
	    $used_pfx{$xpfx} = 1
		unless $prefix =~ /EXTRA_/;

	    push (@sources, '$(' . $prefix . $one_file . "_SOURCES)");
	    push (@objects, '$(' . $xpfx . $one_file . "_OBJECTS)")
		unless $prefix =~ /EXTRA_/;
	    push (@dist_sources, '$(' . $prefix . $one_file . "_SOURCES)")
		unless $prefix =~ /^nodist_/;
	    local (@conds) = &variable_conditions ($var);
	    if (! @conds)
	    {
		@files = &variable_value_as_list ($var, '');
	    }
	    else
	    {
		local ($cond);
		foreach $cond (@conds)
		{
		    @files = &variable_value_as_list ($var, $cond);
		    ($temp, @result) =
			&handle_single_transform_list ($var, $one_file, $obj,
						       @files);
		    $linker = $temp if $linker eq '';

		    # Define _OBJECTS conditionally.
		    &define_pretty_variable ($xpfx . $one_file . '_OBJECTS',
					     $cond, @result)
			unless $prefix =~ /EXTRA_/;
		}

		next;
	    }
	}

	# Avoid defining needless variables.
	next if (scalar @files == 0);

	($temp, @result) = &handle_single_transform_list ($var, $one_file,
							  $obj, @files);
	$linker = $temp if $linker eq '';
	&define_pretty_variable ($xpfx . $one_file . "_OBJECTS", '', @result)
	    unless $prefix =~ /EXTRA_/;
    }

    local (@keys) = sort keys %used_pfx;
    if (scalar @keys == 0)
    {
	&define_variable ($one_file . "_SOURCES", $unxformed . ".c");
	push (@sources, $unxformed . '.c');
	push (@dist_sources, $unxformed . '.c');
	push (@objects, $unxformed . $obj);
	push (@files, $unxformed . '.c');

	($temp, @result) = &handle_single_transform_list ($one_file . '_SOURCES',
							  $one_file, $obj,
							  @files);
	$linker = $temp if $linker eq '';
	&define_pretty_variable ($one_file . "_OBJECTS", '', @result)
    }
    else
    {
	grep ($_ = '$(' . $_ . $one_file . '_OBJECTS)', @keys);
	&define_pretty_variable ($one_file . '_OBJECTS', '', @keys);
    }

    # If we want to use `LINK' we must make sure it is defined.
    if ($linker eq '')
    {
	$need_link = 1;
    }

    return $linker;
}


# handle_lib_objects ()
# ---------------------
# Special-case @ALLOCA@ and @LIBOBJS@ in _LDADD or _LIBADD variables.
# Also, generate _DEPENDENCIES variable if appropriate.
# Arguments are:
#   transformed name of object being built, or empty string if no object
#   name of _LDADD/_LIBADD-type variable to examine
#   boolean (lex_seen) which is true if a lex source file was seen in this
#     object.  valid only for LDADDs, not LIBADDs.
# Returns 1 if LIBOBJS seen, 0 otherwise.
sub handle_lib_objects
{
    local ($xname, $var, $lex_seen) = @_;
    local ($ret);

    &prog_error ("handle_lib_objects: $var undefined")
	if ! &variable_defined ($var);

    &prog_error ("handle_lib_objects: lex_seen and $var =~ /LIBADD/")
	if $lex_seen && $var =~ /LIBADD/;

    local (@conds) = &variable_conditions ($var);
    if (! @conds)
    {
	$ret = &handle_lib_objects_cond ($xname, $var, $lex_seen, '');
    }
    else
    {
	local ($cond);
	$ret = 0;
	foreach $cond (@conds)
	{
	    if (&handle_lib_objects_cond ($xname, $var, $lex_seen, $cond))
	    {
		$ret = 1;
	    }
	}
    }

    return $ret;
}

# Subroutine of handle_lib_objects: handle a particular condition.
sub handle_lib_objects_cond
{
    local ($xname, $var, $lex_seen, $cond) = @_;

    # We recognize certain things that are commonly put in LIBADD or
    # LDADD.
    local ($lsearch);
    local (@dep_list) = ();

    local ($seen_libobjs) = 0;
    local ($flagvar) = 0;

    foreach $lsearch (&variable_value_as_list ($var, $cond))
    {
	# Skip -lfoo and -Ldir; these are explicitly allowed.
	next if $lsearch =~ /^-[lL]/;
	if (! $flagvar && $lsearch =~ /^-/)
	{
	    if ($var =~ /^(.*)LDADD$/)
	    {
		# Skip -dlopen and -dlpreopen; these are explicitly allowed.
		next if $lsearch =~ /^-dl(pre)?open$/;
		&am_line_error ($var, "linker flags such as \`$lsearch' belong in \`${1}LDFLAGS");
	    }
	    else
	    {
		# Only get this error once.
		$flagvar = 1;
		&am_line_error ($var, "linker flags such as \`$lsearch' belong in \`${1}LDFLAGS");
	    }
	}

	# Assume we have a file of some sort, and push it onto the
	# dependency list.  Autoconf substitutions are not pushed;
	# rarely is a new dependency substituted into (eg) foo_LDADD
	# -- but "bad things (eg -lX11) are routinely substituted.
	# Note that LIBOBJS and ALLOCA are exceptions to this rule,
	# and handled specially below.
	push (@dep_list, $lsearch)
	    unless $lsearch =~ /^\@.*\@$/;

	# Automatically handle @LIBOBJS@ and @ALLOCA@.  Basically this
	# means adding entries to dep_files.
	if ($lsearch =~ /^\@(LT)?LIBOBJS\@$/)
	{
	    local ($myobjext) = ($1 ? 'l' : '') . 'o';

	    push (@dep_list, $lsearch);
	    $seen_libobjs = 1;
	    if (! keys %libsources
		&& ! &variable_defined ($1 . 'LIBOBJS'))
	    {
		&am_line_error ($var, "\@$1" . "LIBOBJS\@ seen but never set in \`$configure_ac'");
	    }

	    local ($iter, $rewrite);
	    foreach $iter (keys %libsources)
	    {
		if ($iter =~ /\.([cly])$/)
		{
		    &saw_extension ($1);
		    &saw_extension ('c');
		}

		if ($iter =~ /\.h$/)
		{
		    &require_file_with_line ($var, $FOREIGN, $iter);
		}
		elsif ($iter ne 'alloca.c')
		{
		    ($rewrite = $iter) =~ s/\.c$/.P$myobjext/;
		    $dep_files{'$(DEPDIR)/' . $rewrite} = 1;
		    ($rewrite = $iter) =~ s/(\W)/\\$1/g;
		    $rewrite = "^" . $rewrite . "\$";
		    # Only require the file if it is not a built source.
		    if (! &variable_defined ('BUILT_SOURCES')
			|| ! grep (/$rewrite/,
				   &variable_value_as_list ('BUILT_SOURCES',
							    'all')))
		    {
			&require_file_with_line ($var, $FOREIGN, $iter);
		    }
		}
	    }
	}
	elsif ($lsearch =~ /^\@(LT)?ALLOCA\@$/)
	{
	    local ($myobjext) = ($1 ? 'l' : '') . 'o';

	    push (@dep_list, $lsearch);
	    &am_line_error ($var,
			    "\@$1" . "ALLOCA\@ seen but \`AC_FUNC_ALLOCA' not in \`$configure_ac'")
		if ! defined $libsources{'alloca.c'};
	    $dep_files{'$(DEPDIR)/alloca.P' . $myobjext} = 1;
	    &require_file_with_line ($var, $FOREIGN, 'alloca.c');
	    &saw_extension ('c');
	}
    }

    if ($xname ne '' && ! &variable_defined ($xname . '_DEPENDENCIES', $cond))
    {
	&define_pretty_variable ($xname . '_DEPENDENCIES', $cond, @dep_list);
    }

    return $seen_libobjs;
}

# Canonicalize a name, and check to make sure the non-canonical name
# is never used.  Returns canonical name.  Arguments are name and a
# list of suffixes to check for.
sub check_canonical_spelling
{
    local ($name, @suffixes) = @_;
    local ($xname, $xt);

    ($xname = $name) =~ tr/A-Za-z0-9_/_/c;
    if ($xname ne $name)
    {
	local ($xt);
	foreach $xt (@suffixes)
	{
	    &am_line_error ($name . $xt,
			    "invalid variable \`" . $name . $xt
			    . "'; should be \`" . $xname . $xt . "'")
		if &variable_defined ($name . $xt);
	}
    }

    return $xname;
}


# handle_programs ()
# ------------------
# Handle C programs.
sub handle_programs
{
    local (@proglist) = &am_install_var ('-clean',
					 'progs', 'PROGRAMS',
					 'bin', 'sbin', 'libexec', 'pkglib',
					 'noinst', 'check');
    return if ! @proglist;

    # If a program is installed, this is required.  We only want this
    # error to appear once.
    &am_conf_error ("AC_ARG_PROGRAM must be used")
	unless $seen_arg_prog;
    $seen_arg_prog = 1;

    local ($one_file, $xname, $munge);

    local ($seen_libobjs) = 0;
    foreach $one_file (@proglist)
    {
	local ($obj) = &get_object_extension ($one_file);

	# Canonicalize names and check for misspellings.
	$xname = &check_canonical_spelling ($one_file, '_LDADD', '_LDFLAGS',
					    '_SOURCES', '_OBJECTS',
					    '_DEPENDENCIES');

	# FIXME: Using a trick to figure out if any lex sources appear
	# in our program; should use some cleaner method.
	local ($lex_num) = scalar (keys %lex_sources);
	local ($linker) = &handle_source_transform ($xname, $one_file, $obj);
	local ($lex_file_seen) = (scalar (keys %lex_sources) > $lex_num);

	local ($xt) = '';
	if (&variable_defined ($xname . "_LDADD"))
	{
	    if (&handle_lib_objects ($xname, $xname . '_LDADD',
				     $lex_file_seen))
	    {
		$seen_libobjs = 1;
	    }
	    $lex_file_seen = 0;
	    $xt = '_LDADD';
	}
	else
	{
	    # User didn't define prog_LDADD override.  So do it.
	    &define_variable ($xname . '_LDADD', '$(LDADD)');

	    # This does a bit too much work.  But we need it to
	    # generate _DEPENDENCIES when appropriate.
	    if (&variable_defined ('LDADD'))
	    {
		if (&handle_lib_objects ($xname, 'LDADD', $lex_file_seen))
		{
		    $seen_libobjs = 1;
		}
		$lex_file_seen = 0;
	    }
	    elsif (! &variable_defined ($xname . '_DEPENDENCIES'))
	    {
		&define_variable ($xname . '_DEPENDENCIES', '');
	    }
	    $xt = '_SOURCES'
	}

	if (&variable_defined ($xname . '_LIBADD'))
	{
	    &am_line_error ($xname . '_LIBADD',
			    "use \`" . $xname . "_LDADD', not \`"
			    . $xname . "_LIBADD'");
	}

	if (! &variable_defined ($xname . '_LDFLAGS'))
	{
	    # Define the prog_LDFLAGS variable.
	    &define_variable ($xname . '_LDFLAGS', '');
	}

	# Determine program to use for link.
	local ($xlink);
	if (&variable_defined ($xname . '_LINK'))
	{
	    $xlink = $xname . '_LINK';
	}
	else
	{
	    $xlink = $linker ? $linker : 'LINK';
	}

	local ($exeext) = '';
	if ($seen_exeext && $one_file !~ /\./)
	{
	    $exeext = '$(EXEEXT)';
	}

	$output_rules .= &file_contents ('program',
					 &transform ('EXEEXT'   => $exeext,
						     'PROGRAM'  => $one_file,
						     'XPROGRAM' => $xname,
						     'XLINK'    => $xlink));
    }

    if (&variable_defined ('LDADD') && &handle_lib_objects ('', 'LDADD', 0))
    {
	$seen_libobjs = 1;
    }

    if ($seen_libobjs)
    {
	foreach $one_file (@proglist)
	{
	    # Canonicalize names.
	    ($xname = $one_file) =~ tr/A-Za-z0-9_/_/c;

	    if (&variable_defined ($xname . '_LDADD'))
	    {
		&check_libobjs_sources ($xname, $xname . '_LDADD');
	    }
	    elsif (&variable_defined ('LDADD'))
	    {
		&check_libobjs_sources ($xname, 'LDADD');
	    }
	}
    }
}


# handle_libraries ()
# -------------------
# Handle libraries.
sub handle_libraries
{
    local (@liblist) = &am_install_var ('-clean',
					'libs', 'LIBRARIES',
					'lib', 'pkglib', 'noinst', 'check');
    return if ! @liblist;

    local (%valid) = &am_primary_prefixes ('LIBRARIES', 0, 'lib', 'pkglib',
					   'noinst', 'check');
    if (! defined $configure_vars{'RANLIB'})
    {
	local ($key);
	foreach $key (keys %valid)
	{
	    if (&variable_defined ($key . '_LIBRARIES'))
	    {
		&am_line_error ($key . '_LIBRARIES', "library used but \`RANLIB' not defined in \`$configure_ac'");
		# Only get this error once.  If this is ever printed,
		# we have a bug.
		$configure_vars{'RANLIB'} = 'BUG';
		last;
	    }
	}
    }

    local ($onelib);
    local ($munge);
    local ($xlib);
    local ($seen_libobjs) = 0;
    foreach $onelib (@liblist)
    {
	# Check that the library fits the standard naming convention.
	if ($onelib !~ /^lib.*\.a$/)
	{
	    # FIXME should put line number here.  That means mapping
	    # from library name back to variable name.
	    &am_error ("\`$onelib' is not a standard library name");
	}

	local ($obj) = &get_object_extension ($onelib);

	# Canonicalize names and check for misspellings.
	$xlib = &check_canonical_spelling ($onelib, '_LIBADD', '_SOURCES',
					   '_OBJECTS', '_DEPENDENCIES', '_AR');

	if (! &variable_defined ($xlib . '_AR'))
	{
	    &define_variable ($xlib . '_AR', '$(AR) cru');
	}

	if (&variable_defined ($xlib . '_LIBADD'))
	{
	    if (&handle_lib_objects ($xlib, $xlib . '_LIBADD', 0))
	    {
		$seen_libobjs = 1;
	    }
	}
	else
	{
	    # Generate support for conditional object inclusion in
	    # libraries.
	    &define_variable ($xlib . "_LIBADD", '');
	}

	if (&variable_defined ($xlib . '_LDADD'))
	{
	    &am_line_error ($xlib . '_LDADD',
			    "use \`" . $xlib . "_LIBADD', not \`"
			    . $xlib . "_LDADD'");
	}

	# Make sure we at look at this.
	&examine_variable ($xlib . '_DEPENDENCIES');

	&handle_source_transform ($xlib, $onelib, $obj);

	$output_rules .= &file_contents ('library',
					 &transform ('LIBRARY'  => $onelib,
						     'XLIBRARY' => $xlib));
    }

    if ($seen_libobjs)
    {
	foreach $onelib (@liblist)
	{
	    # Canonicalize names.
	    ($xlib = $onelib) =~ tr/A-Za-z0-9_/_/c;
	    if (&variable_defined ($xlib . '_LIBADD'))
	    {
		&check_libobjs_sources ($xlib, $xlib . '_LIBADD');
	    }
	}
    }

    &define_variable ('AR', 'ar');
    &define_configure_variable ('RANLIB');
}


# handle_ltlibraries ()
# ---------------------
# Handle shared libraries.
sub handle_ltlibraries
{
    local (@liblist) = &am_install_var ('-clean',
					'ltlib', 'LTLIBRARIES',
					'noinst', 'lib', 'pkglib', 'check');
    return if ! @liblist;

    local (%instdirs);
    local (%valid) = &am_primary_prefixes ('LTLIBRARIES', 0, 'lib', 'pkglib',
					   'noinst', 'check');

    local ($key);
    foreach $key (keys %valid)
    {
	if (&variable_defined ($key . '_LTLIBRARIES'))
	{
	    if (!$seen_libtool)
	    {
		&am_line_error ($key . '_LTLIBRARIES', "library used but \`LIBTOOL' not defined in \`$configure_ac'");
		# Only get this error once.  If this is ever printed,
		# we have a bug.
		$configure_vars{'LIBTOOL'} = 'BUG';
		$seen_libtool = 1;
	    }

	    # Get the installation directory of each library.
	    for (&variable_value_as_list ($key . '_LTLIBRARIES', 'all'))
	    {
		if ($instdirs{$_})
		{
		    &am_error ("\`$_' is already going to be installed in \`$instdirs{$_}'");
		}
		else
		{
		    $instdirs{$_} = $key;
		}
	    }
	}
    }

    local ($onelib);
    local ($munge);
    local ($xlib);
    local ($seen_libobjs) = 0;
    foreach $onelib (@liblist)
    {
	local ($obj) = &get_object_extension ($onelib);

	# Canonicalize names and check for misspellings.
	$xlib = &check_canonical_spelling ($onelib, '_LIBADD', '_LDFLAGS',
					   '_SOURCES', '_OBJECTS',
					   '_DEPENDENCIES');

	if (! &variable_defined ($xlib . '_LDFLAGS'))
	{
	    # Define the lib_LDFLAGS variable.
	    &define_variable ($xlib . '_LDFLAGS', '');
	}

	# Check that the library fits the standard naming convention.
    	$libname_rx = "^lib.*\.la";
	if ((&variable_defined ($xlib . '_LDFLAGS')
	     && grep (/-module/, &variable_value_as_list ($xlib . '_LDFLAGS',
							  'all')))
	    || (&variable_defined ('LDFLAGS')
		&& grep (/-module/, &variable_value_as_list ('LDFLAGS',
							     'all'))))
	{
		# Relax name checking for libtool modules.
	    	$libname_rx = "\.la";
	}
	if ($onelib !~ /$libname_rx$/)
	{
	    # FIXME this should only be a warning for foreign packages
	    # FIXME should put line number here.  That means mapping
	    # from library name back to variable name.
	    &am_error ("\`$onelib' is not a standard libtool library name");
	}

	if (&variable_defined ($xlib . '_LIBADD'))
	{
	    if (&handle_lib_objects ($xlib, $xlib . '_LIBADD', 0))
	    {
		$seen_libobjs = 1;
	    }
	}
	else
	{
	    # Generate support for conditional object inclusion in
	    # libraries.
	    &define_variable ($xlib . "_LIBADD", '');
	}

	if (&variable_defined ($xlib . '_LDADD'))
	{
	    &am_line_error ($xlib . '_LDADD',
			    "use \`" . $xlib . "_LIBADD', not \`"
			    . $xlib . "_LDADD'");
	}

	# Make sure we at look at this.
	&examine_variable ($xlib . '_DEPENDENCIES');

	local ($linker) = &handle_source_transform ($xlib, $onelib, $obj);

	# Determine program to use for link.
	local ($xlink);
	if (&variable_defined ($xlib . '_LINK'))
	{
	    $xlink = $xlib . '_LINK';
	}
	else
	{
	    $xlink = $linker ? $linker : 'LINK';
	}

	local ($rpath);
	if ($instdirs{$onelib} eq 'EXTRA'
	    || $instdirs{$onelib} eq 'noinst'
	    || $instdirs{$onelib} eq 'check')
	{
	    # It's an EXTRA_ library, so we can't specify -rpath,
	    # because we don't know where the library will end up.
	    # The user probably knows, but generally speaking automake
	    # doesn't -- and in fact configure could decide
	    # dynamically between two different locations.
	    $rpath = '';
	}
	else
	{
	    $rpath = ('-rpath $(' . $instdirs{$onelib} . 'dir)');
	}

	$output_rules .= &file_contents ('ltlibrary',
					 &transform ('LTLIBRARY'  => $onelib,
						     'XLTLIBRARY' => $xlib,
						     'RPATH'      => $rpath,
						     'XLINK'      => $xlink));
    }

    if ($seen_libobjs)
    {
	foreach $onelib (@liblist)
	{
	    # Canonicalize names.
	    ($xlib = $onelib) =~ tr/A-Za-z0-9_/_/c;
	    if (&variable_defined ($xlib . '_LIBADD'))
	    {
		&check_libobjs_sources ($xlib, $xlib . '_LIBADD');
	    }
	}
    }
}

# See if any _SOURCES variable were misspelled.  Also, make sure that
# EXTRA_ variables don't contain configure substitutions.
sub check_typos
{
    local ($varname, $primary);
    foreach $varname (keys %contents)
    {
	foreach $primary ('_SOURCES', '_LIBADD', '_LDADD', '_LDFLAGS',
			  '_DEPENDENCIES')
	{
	    if ($varname =~ /$primary$/ && ! $content_seen{$varname})
	    {
		&am_line_error ($varname,
				"invalid unused variable name: \`$varname'");
	    }
	}
    }
}

# Handle scripts.
sub handle_scripts
{
    # NOTE we no longer automatically clean SCRIPTS, because it is
    # useful to sometimes distribute scripts verbatim.  This happens
    # eg in Automake itself.
    &am_install_var ('-candist', 'scripts', 'SCRIPTS',
		     'bin', 'sbin', 'libexec', 'pkgdata',
		     'noinst', 'check');

    local ($scripts_installed) = 0;
    # Set $scripts_installed if appropriate.  Make sure we only find
    # scripts which are actually installed -- this is why we can't
    # simply use the return value of am_install_var.
    local (%valid) = &am_primary_prefixes ('SCRIPTS', 1, 'bin', 'sbin',
					   'libexec', 'pkgdata',
					   'noinst', 'check');
    local ($key);
    foreach $key (keys %valid)
    {
	if ($key ne 'noinst'
	    && $key ne 'check'
	    && &variable_defined ($key . '_SCRIPTS'))
	{
	    $scripts_installed = 1;
	    # push (@check_tests, 'check-' . $key . 'SCRIPTS');
	}
    }

    if ($scripts_installed)
    {
	# If a program is installed, this is required.  We only want this
	# error to appear once.
	&am_conf_error ("AC_ARG_PROGRAM must be used")
	    unless $seen_arg_prog;
	$seen_arg_prog = 1;
    }
}

# Search a file for a "version.texi" Texinfo include.  Return the name
# of the include file if found, or the empty string if not.  A
# "version.texi" file is actually any file whose name matches
# "vers*.texi".
sub scan_texinfo_file
{
    local ($filename) = @_;

    if (! open (TEXI, $filename))
    {
	&am_error ("couldn't open \`$filename': $!");
	return '';
    }
    print "automake: reading $filename\n" if $verbose;

    local ($vfile, $outfile);
    while (<TEXI>)
    {
	if (/^\@setfilename +(\S+)/)
	{
	    $outfile = $1;
	    last if ($vfile);
	}

	if (/^\@include\s+(vers[^.]*\.texi)\s*$/)
	{
	    # Found version.texi include.
	    $vfile = $1;
	    last if $outfile;
	}
    }

    close (TEXI);
    return ($outfile, $vfile);
}


# handle_texinfo ()
# -----------------
# Handle all Texinfo source.
sub handle_texinfo
{
    &am_line_error ('TEXINFOS',
		    "\`TEXINFOS' is an anachronism; use \`info_TEXINFOS'")
	if &variable_defined ('TEXINFOS');
    return if (! &variable_defined ('info_TEXINFOS')
	       && ! &variable_defined ('html_TEXINFOS'));

    if (&variable_defined ('html_TEXINFOS'))
    {
	&am_line_error ('html_TEXINFOS',
			"HTML generation not yet supported");
	return;
    }

    local (@texis) = &variable_value_as_list ('info_TEXINFOS', 'all');

    local (@info_deps_list, @dvis_list, @texi_deps);
    local ($infobase, $info_cursor);
    local (%versions);
    local ($done) = 0;
    local ($vti);
    local ($tc_cursor, @texi_cleans);
    local ($canonical);

    foreach $info_cursor (@texis)
    {
	# FIXME: This is mildly hacky, since it recognizes "txinfo".
	# I don't feel like making it right.
	($infobase = $info_cursor) =~ s/\.te?xi(nfo)?$//;

	# If 'version.texi' is referenced by input file, then include
	# automatic versioning capability.
	local ($out_file, $vtexi) = &scan_texinfo_file ($relative_dir
							. "/" . $info_cursor);

	if ($out_file eq '')
	{
	    &am_error ("\`$info_cursor' missing \@setfilename");
	    next;
	}

	if ($out_file =~ /\.(.+)$/ && $1 ne 'info')
	{
	    # FIXME should report line number in input file.
	    &am_error ("output of \`$info_cursor', \`$out_file', has unrecognized extension");
	    next;
	}

	if ($vtexi)
	{
	    &am_error ("\`$vtexi', included in \`$info_cursor', also included in \`$versions{$vtexi}'")
		if (defined $versions{$vtexi});
	    $versions{$vtexi} = $info_cursor;

	    # We number the stamp-vti files.  This is doable since the
	    # actual names don't matter much.  We only number starting
	    # with the second one, so that the common case looks nice.
	    $vti = ($done ? $done : 'vti');
	    ++$done;

	    &push_dist_common ($vtexi, 'stamp-' . $vti);
	    &depend ('clean', $vti);

	    &require_conf_file_with_line ('info_TEXINFOS', $FOREIGN,
					  'mdate-sh');

	    local ($conf_dir);
	    if ($config_aux_dir eq '.' || $config_aux_dir eq '')
	    {
		$conf_dir = '$(srcdir)/';
	    }
	    else
	    {
		$conf_dir = $config_aux_dir;
		$conf_dir .= '/' unless $conf_dir =~ /\/$/;
	    }
	    $output_rules .=
		&file_contents ('texi-vers',
				&transform ('TEXI'         => $info_cursor,
					    'VTI'          => $vti,
					    'VTEXI'        => $vtexi,
					    'MDDIR'        => $conf_dir,
					    'CONFIGURE_AC' => $configure_ac));

	    &push_phony_cleaners ($vti);
	}

	# If user specified file_TEXINFOS, then use that as explicit
	# dependency list.
	@texi_deps = ();
	push (@texi_deps, $info_cursor);
	# Prefix with $(srcdir) because some version of make won't
	# work if the target has it and the dependency doesn't.
	push (@texi_deps, '$(srcdir)/' . $vtexi) if $vtexi;

	# Canonicalize name first.
	($canonical = $infobase) =~ tr/A-Za-z0-9_/_/c;
	if (&variable_defined ($canonical . "_TEXINFOS"))
	{
	    push (@texi_deps, '$(' . $canonical . '_TEXINFOS)');
	    &push_dist_common ('$(' . $canonical . '_TEXINFOS)');
	}

	$output_rules .= ("\n" . $out_file . ": "
			  . join (' ', @texi_deps)
			  . "\n" . $infobase . ".dvi: "
			  . join (' ', @texi_deps)
			  . "\n\n");

	push (@info_deps_list, $out_file);
	push (@dvis_list, $infobase . '.dvi');

	# Generate list of things to clean for this target.  We do
	# this explicitly because otherwise too many things could be
	# removed.  In particular the ".log" extension might
	# reasonably be used in other contexts by the user.
	# FIXME: this is really out of control.
	foreach $tc_cursor ('aux', 'cp', 'cps', 'dvi', 'fn', 'fns', 'pgs',
			    'ky', 'kys', 'ps', 'log', 'pg', 'toc', 'tp', 'tps',
			    'vr', 'vrs', 'op', 'tr', 'cv', 'cn', 'cm', 'ov')
	{
	    push (@texi_cleans, $infobase . '.' . $tc_cursor);
	}
    }

    # Find these programs wherever they may lie.  Yes, this has
    # intimate knowledge of the structure of the texinfo distribution.
    &define_program_variable ('MAKEINFO', 'build', 'texinfo/makeinfo',
			      'makeinfo',
			      # Circumlocution to avoid accidental
			      # configure substitution.
			      '@MAKE' . 'INFO@');
    &define_program_variable ('TEXI2DVI', 'src', 'texinfo/util',
			      'texi2dvi');

    # Set transform for including texinfos.am.  First, handle --cygnus
    # stuff.
    local ($xform);
    if ($cygnus_mode)
    {
	$xform = 's/^NOTCYGNUS.*$//; s/^CYGNUS//;';
    }
    else
    {
	$xform = 's/^CYGNUS.*$//; s/^NOTCYGNUS//;';
    }

    # Handle location of texinfo.tex.
    local ($need_texi_file) = 0;
    local ($texinfodir);
    if ($cygnus_mode)
    {
        $texinfodir = '$(top_srcdir)/../texinfo';
	&define_variable ('TEXINFO_TEX', "$texinfodir/texinfo.tex");

    }
    elsif ($config_aux_dir ne '.' && $config_aux_dir ne '')
    {
        $texinfodir = $config_aux_dir;
	&define_variable ('TEXINFO_TEX', "$texinfodir/texinfo.tex");
	$need_texi_file = 2; # so that we require_conf_file later
    }
    elsif (&variable_defined ('TEXINFO_TEX'))
    {
	# The user defined TEXINFO_TEX so assume he knows what he is
	# doing.
        $texinfodir = ('$(srcdir)/'
		       . &dirname (&variable_value ('TEXINFO_TEX')));
    }
    else
    {
        $texinfodir = '$(srcdir)';
	$need_texi_file = 1;
    }
    $xform .= &transform ('TEXINFODIR' => $texinfodir);

    $output_rules .= &file_contents ('texinfos', $xform);
    push (@dist_targets, 'dist-info');

    # How to clean.  The funny name is due to --cygnus influence; in
    # Cygnus mode, `clean-info' is a target that users can use.
    $output_rules .= "\nmostlyclean-aminfo:\n";
    &pretty_print_rule ("\t-rm -f", "\t  ", @texi_cleans);
    $output_rules .= ("\nclean-aminfo:\n\ndistclean-aminfo:\n\n"
		      . "maintainer-clean-aminfo:\n\t"
		      # Eww.  But how else can we find all the output
		      # files from makeinfo?
		      . ($cygnus_mode ? '' : 'cd $(srcdir) && ')
		      . 'for i in $(INFO_DEPS); do' . " \\\n"
		      . "\t" . '  rm -f $$i;' . " \\\n"
		      . "\t" . '  if test "`echo $$i-[0-9]*`" != "$$i-[0-9]*"; then' . " \\\n"
		      . "\t" . '    rm -f $$i-[0-9]*;' . " \\\n"
		      . "\t" . '  fi;' . " \\\n"
		      . "\tdone\n");
    &push_phony_cleaners ('aminfo');
    if ($cygnus_mode)
    {
	$output_rules .= "clean-info: mostlyclean-aminfo\n";
    }

    push (@suffixes, '.texi', '.texinfo', '.txi', '.info', '.dvi', '.ps');

    if (! defined $options{'no-installinfo'})
    {
	push (@uninstall, 'uninstall-info');
	push (@installdirs, '$(DESTDIR)$(infodir)');
	unshift (@install_data, 'install-info-am');

	# Make sure documentation is made and installed first.  Use
	# $(INFO_DEPS), not 'info', because otherwise recursive makes
	# get run twice during "make all".
	unshift (@all, '$(INFO_DEPS)');
    }
    &depend ('clean', 'aminfo');
    push (@info, '$(INFO_DEPS)');
    push (@dvi, '$(DVIS)');

    &define_variable ("INFO_DEPS", join (' ', @info_deps_list));
    &define_variable ("DVIS", join (' ', @dvis_list));
    # This next isn't strictly needed now -- the places that look here
    # could easily be changed to look in info_TEXINFOS.  But this is
    # probably better, in case noinst_TEXINFOS is ever supported.
    &define_variable ("TEXINFOS", &variable_value ('info_TEXINFOS'));

    # Do some error checking.  Note that this file is not required
    # when in Cygnus mode; instead we defined TEXINFO_TEX explicitly
    # up above.
    if ($need_texi_file && ! defined $options{'no-texinfo.tex'})
    {
	if ($need_texi_file > 1)
	{
	    &require_conf_file_with_line ('info_TEXINFOS', $FOREIGN,
					  'texinfo.tex');
	}
	else
	{
	    &require_file_with_line ('info_TEXINFOS', $FOREIGN, 'texinfo.tex');
	}
    }
}

# Handle any man pages.
sub handle_man_pages
{
    &am_line_error ('MANS', "\`MANS' is an anachronism; use \`man_MANS'")
	if &variable_defined ('MANS');

    # Find all the sections in use.  We do this by first looking for
    # "standard" sections, and then looking for any additional
    # sections used in man_MANS.
    local ($sect, %sections, %vlist);
    local ($found) = 0;
    # Add more sections as needed.
    foreach $sect ('0'..'9', 'n', 'l')
    {
	if (&variable_defined ('man' . $sect . '_MANS'))
	{
	    $sections{$sect} = 1;
	    $vlist{'$(man' . $sect . '_MANS)'} = 1;
	    $found = 1;
	}
    }

    if (&variable_defined ('man_MANS'))
    {
	$vlist{'$(man_MANS)'} = 1;
	foreach (&variable_value_as_list ('man_MANS', 'all'))
	{
	    # A page like `foo.1c' goes into man1dir.
	    if (/\.([0-9a-z])([a-z]*)$/)
	    {
		$sections{$1} = 1;
		$found = 1;
	    }
	}
    }

    return unless $found;

    # Now for each section, generate an install and unintall rule.
    # Sort sections so output is deterministic.
    local (@namelist);
    foreach $sect (sort keys %sections)
    {
	&define_variable ('man' . $sect . 'dir', '$(mandir)/man' . $sect);
	push (@installdirs, '$(DESTDIR)$(mandir)/man' . $sect)
	    unless defined $options{'no-installman'};
	$output_rules .= &file_contents ('mans',
					 &transform ('SECTION', $sect));
	push (@namelist, 'install-man' . $sect);
    }

    # We don't really need this, but we use it in case we ever want to
    # support noinst_MANS.
    &define_variable ("MANS", join (' ', sort keys %vlist));

    # Generate list of install dirs.
    $output_rules .= ("install-man: \$(MANS)\n"
		      . "\t\@\$(NORMAL_INSTALL)\n");
    &pretty_print_rule ("\t\$(MAKE) \$(AM_MAKEFLAGS)", "\t ", @namelist);
    &depend ('.PHONY', 'install-man');

    $output_rules .= "uninstall-man:\n\t\@\$(NORMAL_UNINSTALL)\n";
    grep ($_ = 'un' . $_, @namelist);
    &pretty_print_rule ("\t\$(MAKE) \$(AM_MAKEFLAGS)", "\t ", @namelist);
    &depend ('.PHONY', 'uninstall-man');

    $output_vars .= &file_contents ('mans-vars');

    if (! defined $options{'no-installman'})
    {
	push (@install_data, 'install-man');
	push (@uninstall, 'uninstall-man');
	push (@all, '$(MANS)');
    }
}

# Handle DATA variables.
sub handle_data
{
    &am_install_var ('-noextra', '-candist', 'data', 'DATA',
		     'data', 'sysconf', 'sharedstate', 'localstate',
		     'pkgdata', 'noinst', 'check');
}

# Handle TAGS.
sub handle_tags
{
    local (@tag_deps) = ();
    if (&variable_defined ('SUBDIRS'))
    {
	$output_rules .= ("tags-recursive:\n"
			  . "\tlist=\'\$(SUBDIRS)\'; for subdir in \$\$list; do \\\n"
			  # Never fail here if a subdir fails; it
			  # isn't important.
			  . "\t  test \"\$\$subdir\" = . || (cd \$\$subdir"
			  . " && \$(MAKE) \$(AM_MAKEFLAGS) tags); \\\n"
			  . "\tdone\n");
	push (@tag_deps, 'tags-recursive');
	&depend ('.PHONY', 'tags-recursive');
    }

    if (&saw_sources_p (1)
	|| &variable_defined ('ETAGS_ARGS')
	|| @tag_deps)
    {
	local ($config) = '';
	local ($one_hdr);
	foreach $one_hdr (@config_headers)
	{
	    if ($relative_dir eq &dirname ($one_hdr))
	    {
		# The config header is in this directory.  So require it.
		$config .= ' ' if $config;
		$config .= &basename ($one_hdr);
	    }
	}
	local $xform = &transform ('CONFIG' => $xform,
				   'DIRS'   => join (' ', @tag_deps));

	if (&variable_defined ('SUBDIRS'))
	{
	    $xform .= 's/^SUBDIRS//;';
	}
	else
	{
	    $xform .= 's/^SUBDIRS.*$//;';
	}

	$output_rules .= &file_contents ('tags', $xform);
	$output_rules .= &file_contents ('tags-clean');
	&depend ('clean', 'tags');
	&push_phony_cleaners ('tags');
	&examine_variable ('TAGS_DEPENDENCIES');
    }
    elsif (&variable_defined ('TAGS_DEPENDENCIES'))
    {
	&am_line_error ('TAGS_DEPENDENCIES',
			"doesn't make sense to define \`TAGS_DEPENDENCIES' without sources or \`ETAGS_ARGS'");
    }
    else
    {
	# Every Makefile must define some sort of TAGS rule.
	# Otherwise, it would be possible for a top-level "make TAGS"
	# to fail because some subdirectory failed.
	$output_rules .= "tags: TAGS\nTAGS:\n\n";
    }
}

# Handle multilib support.
sub handle_multilib
{
    return unless $seen_multilib;

    $output_rules .= &file_contents ('multilib');
    &push_phony_cleaners ('multi');
}

# Worker for handle_dist.
sub handle_dist_worker
{
    my ($makefile) = @_;
    my $xform = '';

    # Initialization; only at top level.
    if ($relative_dir eq '.')
    {
        $xform .= 's/\@TOPDIR\@//g;';
    }
    else
    {
        $xform .= 's/\@TOPDIR\@.*//g;';
    }

    if (defined $options{'check-news'})
    {
        $xform .= 's/\@CK-NEWS\@//g;';
    }
    else
    {
        $xform .= 's/\@CK-NEWS\@.*//g;';
    }

    # Scan EXTRA_DIST to see if we need to distribute anything from a
    # subdir.  If so, add it to the list.  I didn't want to do this
    # originally, but there were so many requests that I finally
    # relented.
    if (&variable_defined ('EXTRA_DIST'))
    {
	# FIXME: This should be fixed to work with conditionals.  That
	# will require only making the entries in @dist_dirs under the
	# appropriate condition.  This is meaningful if the nature of
	# the distribution should depend upon the configure options
	# used.
	foreach (&variable_value_as_list ('EXTRA_DIST', ''))
	{
	    next if /^\@.*\@$/;
	    next unless s,/+[^/]+$,,;
	    $dist_dirs{$_} = 1
		unless $_ eq '.';
	}
    }

    # We have to check DIST_COMMON for extra directories in case the
    # user put a source used in AC_OUTPUT into a subdir.
    foreach (&variable_value_as_list ('DIST_COMMON', 'all'))
    {
	next if /^\@.*\@$/;
	next unless s,/+[^/]+$,,;
	$dist_dirs{$_} = 1
	    unless $_ eq '.';
    }

    if (scalar keys %dist_dirs)
    {
	# Prepend $(distdir) to each directory given.  Doing it via a
	# hash lets us ensure that each directory is used only once.
	grep ($dist_dirs{'$(distdir)/' . $_} = 1, keys %dist_dirs);
	$xform .= &transform ('DISTDIRS', join (' ', sort keys %dist_dirs));
    }
    else
    {
        $xform .= 's/.*\@DISTDIRS\@.*//g;';
    }

    if ($cygnus_mode)
    {
	$xform .= 's/\@CYGNUS\@\t*/\t/g;';
        $xform .= 's/.*\@NCYGNUS\@.*//g;';
    }
    else
    {
	$xform .= 's/\@NCYGNUS\@\t*/\t/g;';
        $xform .= 's/.*\@CYGNUS\@.*//g;';
    }

    # If we have SUBDIRS, create all dist subdirectories and do
    # recursive build.
    if (&variable_defined ('SUBDIRS'))
    {
	# If SUBDIRS is conditionally defined, then set DIST_SUBDIRS
	# to all possible directories, and use it.  If DIST_SUBDIRS is
	# defined, just use it.
	local ($dist_subdir_name);
	if (&variable_conditions ('SUBDIRS')
	    || &variable_defined ('DIST_SUBDIRS'))
	{
	    $dist_subdir_name = 'DIST_SUBDIRS';
	    if (! &variable_defined ('DIST_SUBDIRS'))
	    {
		local (@full_list) = &variable_value_as_list ('SUBDIRS',
							      'all');
		local (@ds_list, %uniq, $iter);
		foreach $iter (@full_list)
		{
		    if (! defined $uniq{$iter})
		    {
			$uniq{$iter} = 1;
			push (@ds_list, $iter);
		    }
		}
		&define_pretty_variable ('DIST_SUBDIRS', '', @ds_list);
	    }
	}
	else
	{
	    $dist_subdir_name = 'SUBDIRS';
	    # We always define this because that is what `distclean'
	    # wants.
	    &define_pretty_variable ('DIST_SUBDIRS', '', '$(SUBDIRS)');
	}

	$xform .= ('s/\@SUBDIRS\@//g;'
		   . &transform ('DIST_SUBDIR_NAME'
				 => $dist_subdir_name,
				 'TOP_DISTDIR'
				 => (($relative_dir eq '.')
				     ? 'distdir' : 'top_distdir')));
    }
    else
    {
	$xform .= 's/\@SUBDIRS\@.*//g;';
    }

    $output_rules .= &file_contents ('distdir', $xform);

    # If the target `dist-hook' exists, make sure it is run.  This
    # allows users to do random weird things to the distribution
    # before it is packaged up.
    push (@dist_targets, 'dist-hook') if &target_defined ('dist-hook');

    local ($targ);
    foreach $targ (@dist_targets)
    {
	# We must explicitly set distdir and top_distdir for these
	# sub-makes.
	$output_rules .= ("\t\$(MAKE) \$(AM_MAKEFLAGS)"
			  . " top_distdir=\"\$(top_distdir)\""
			  . " distdir=\"\$(distdir)\" $targ\n");
    }
}

# Handle 'dist' target.
sub handle_dist
{
    local ($makefile) = @_;

    # Set up maint_charset.
    $local_maint_charset = &variable_value ('MAINT_CHARSET')
	if &variable_defined ('MAINT_CHARSET');
    $maint_charset = $local_maint_charset
	if $relative_dir eq '.';

    if (&variable_defined ('DIST_CHARSET'))
    {
	&am_line_error ('DIST_CHARSET',
			"DIST_CHARSET defined but no MAINT_CHARSET defined")
	    if ! $local_maint_charset;
	if ($relative_dir eq '.')
	{
	    $dist_charset = &variable_value ('DIST_CHARSET')
	}
	else
	{
	    &am_line_error ('DIST_CHARSET',
			    "DIST_CHARSET can only be defined at top level");
	}
    }

    # Look for common files that should be included in distribution.
    local ($cfile);
    foreach $cfile (@common_files)
    {
	if (-f ($relative_dir . "/" . $cfile))
	{
	    &push_dist_common ($cfile);
	}
    }

    # Always require configure.ac and configure at top level, even if
    # they don't exist.  This is especially important for configure,
    # since it won't be created until autoconf is run -- which might
    # be after automake is run.
    &push_dist_common ($configure_ac, 'configure')
	if $relative_dir eq '.';

    # We might copy elements from %configure_dist_common to
    # %dist_common if we think we need to.  If the file appears in our
    # directory, we would have discovered it already, so we don't
    # check that.  But if the file is in a subdir without a Makefile,
    # we want to distribute it here if we are doing `.'.  Ugly!
    if ($relative_dir eq '.')
    {
	local ($iter);
	foreach $iter (keys %configure_dist_common)
	{
	    if (! &is_make_dir (&dirname ($iter)))
	    {
		&push_dist_common ($iter);
	    }
	}
    }

    # Keys of %dist_common are names of files to distributed.  We put
    # README first because it then becomes easier to make a
    # Usenet-compliant shar file (in these, README must be first).
    # FIXME: do more ordering of files here.
    local (@coms);
    if (defined $dist_common{'README'})
    {
	push (@coms, 'README');
	delete $dist_common{'README'};
    }
    push (@coms, sort keys %dist_common);

    # Now that we've processed %dist_common, disallow further attempts
    # to set it.
    $handle_dist_run = 1;

    &define_pretty_variable ("DIST_COMMON", '', @coms);
    $output_vars .= "\n";

    # Some boilerplate.
    $output_vars .= &file_contents ('dist-vars') . "\n";
    &define_variable ('GZIP_ENV', '--best');

    # Put these things in rules section so it is easier for whoever
    # reads Makefile.in.
    if (! &variable_defined ('distdir'))
    {
	if ($relative_dir eq '.')
	{
	    $output_rules .= "\n" . 'distdir = $(PACKAGE)-$(VERSION)' . "\n";
	}
	else
	{
	    $output_rules .= ("\n"
			      . 'distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)'
			      . "\n");
	}
    }
    if ($relative_dir eq '.')
    {
	$output_rules .= "top_distdir = \$(distdir)\n";
    }
    $output_rules .= "\n";

    # Generate 'dist' target, and maybe other dist targets.
    if ($relative_dir eq '.')
    {
	# Rule to check whether a distribution is viable.
	local ($xform) = '';

	if (&target_defined ('distcheck-hook'))
	{
	    $xform .= 's/^DISTHOOK//;';
	}
	else
	{
	    $xform .= 's/^DISTHOOK.*$//;';
	}
	if ($seen_gettext)
	{
	    $xform .= 's/^GETTEXT//;';
	}
	else
	{
	    $xform .= 's/^GETTEXT.*$//;';
	}

	# Arg, this file should have been named `distcheck'.
	$output_rules .= &file_contents ('dist', $xform);

	local ($dist_all) = ('dist-all: distdir' . "\n"
			     . $dist_header);
	local ($curs);
	foreach $curs ('dist', 'dist-shar', 'dist-zip', 'dist-tarZ',
		       'dist-bzip2')
	{
	    if (defined $options{$curs} || $curs eq 'dist')
	    {
		$output_rules .= ($curs . ': distdir' . "\n"
				  . $dist_header
				  . $dist{$curs}
				  . $dist_trailer);
		$dist_all .= $dist{$curs};
	    }
	}
	$output_rules .= $dist_all . $dist_trailer;
    }

    # Generate distdir target.
    &handle_dist_worker ($makefile);
}


# add_depend2 ($LANG)
# -------------------
# A subroutine of handle_dependencies.  This function includes
# `depend2' with appropriate transformations.
sub add_depend2
{
    local ($lang) = @_;

    # Get information on $LANG.
    my $pfx = $language_map{"$lang-autodep"};
    my $fpfx = ($pfx eq '') ? 'CC' : $pfx;
    my $flag = $language_map{"$lang-flags"};

    # First include code for ordinary objects.
    local ($xform, $ext);
    $xform = &transform ('PFX'  => $pfx,
			 'FPFX' => $fpfx);
    $xform .= $seen_objext  ? 's/^OBJEXT//;'  : 's/^OBJEXT.*$//;';
    $xform .= $seen_libtool ? 's/^LIBTOOL//;' : 's/^LIBTOOL.*$//;';

    # This function can be called even when we don't want dependency
    # tracking.  This happens when we need an explicit rule for some
    # target.  In this case we don't want to include the generic code.
    if ($use_dependencies)
    {
        my $compile = '$(' . $pfx . 'COMPILE)';
	my $ltcompile = '$(LT' . $pfx . 'COMPILE)';
	my $xform1 = ($xform
		      . &transform ('BASE'      => '$*',
				    'SOURCE'    => '$<',
				    'OBJ'       => '$@',
				    'LTOBJ'     => '$@',
				    'OBJOBJ'    => '$@',
				    'COMPILE'   => $compile,
				    'LTCOMPILE' => $ltcompile));

	foreach $ext (&lang_extensions ($lang))
	{
	    $output_rules .= (&file_contents ('depend2',
					      &transform ('EXT' => $ext)
					      . $xform1)
			      . "\n");
	}
    }

    # Now include code for each specially handled object with this
    # language.
    local (@list) = grep ($_ ne '', split (' ', $lang_specific_files{$lang}));
    local ($max) = scalar @list;
    local ($i) = 0;
    local ($derived, $source, $obj);

    # If dependency tracking is disabled, we just elide the code.
    if (! $use_dependencies)
    {
	$xform .= 's/\@AMDEP\@.*$//;';
    }

    while ($i < $max)
    {
	$derived = $list[$i];
	$source = $list[$i + 1];
	$obj = $list[$i + 2];
	$i += 3;

	my $val = "${derived}_${flag}";

	my $obj_compile = $language_map{"$lang-compile"};
	$obj_compile =~ s/\(AM_$flag/\($val/;
	my $obj_ltcompile = '$(LIBTOOL) --mode=compile ' . $obj_compile;

	# Generate a transform which will turn suffix targets in
	# depend2.am into real targets for the particular objects we
	# are building.
	$output_rules .=
	    &file_contents
	        ('depend2',
		 $xform
		 . &transform ('COMPILE'   => $obj_compile,
			       'LTCOMPILE' => $obj_ltcompile,
			       # Handle source and obj transforms.
			       'OBJ'       => $obj . '.o',
			       'OBJOBJ'    => $obj . '.obj',
			       'LTOBJ'     => $obj . '.lo',
			       'BASE'      => $obj,
			       'SOURCE'    => $source)
		 # Generate rule for `.o'.
		 . 's/^\@EXT\@\.o:/' . "\Q$obj.o: $source\E" . '/g;'
		 # Maybe generate rule for `.lo'.  Might be eliminated
		 # by $XFORM.
		 . 's/^\@EXT\@\.lo:/' . "\Q$obj.lo: $source\E" . '/g;'
		 # Maybe generate rule for `.obj'.  Might be
		 # eliminated by $XFORM.
		 . 's/^\@EXT\@\.obj:/' . "\Q$obj.obj: $source\E" . '/g;');
    }
}

# Handle auto-dependency code.
sub handle_dependencies
{
    if ($use_dependencies)
    {
	# Include auto-dep code.  Don't include it if DEP_FILES would
	# be empty.
	if (&saw_sources_p (0) && keys %dep_files)
	{
	    local ($config_aux_dir_specified) = ($config_aux_dir ne '.'
						 && $config_aux_dir ne '');

	    # Set $require_file_found{'depcomp'} if the depcomp file exists,
	    # before calling require_config_file on `depcomp'.  This makes
	    # require_file_internal skip its buggy existence test that would
	    # make automake fail (with `required file `lib/depcomp' not found')
	    # when AC_CONFIG_AUX_DIR is not set.  See tests/subdir4.test.
	    local ($depcomp_dir) = ($config_aux_dir_specified ? $config_aux_dir
				    : '.');
	    $require_file_found{'depcomp'} = 1 if -f "$depcomp_dir/depcomp";

	    # Set location of depcomp.
	    local ($prefix) = ($config_aux_dir_specified ? $config_aux_dir
			       : '$(top_srcdir)');

	    &define_variable ('depcomp', "\$(SHELL) $prefix/depcomp");

	    &require_config_file ($FOREIGN, 'depcomp');

	    local ($iter);
	    local (@deplist) = sort keys %dep_files;

	    # We define this as a conditional variable because BSD
	    # make can't handle backslashes for continuing comments on
	    # the following line.
	    &define_pretty_variable ('DEP_FILES', "\@AMDEP\@", @deplist);

	    # Generate each `include' individually.  Irix 6 make will
	    # not properly include several files resulting from a
	    # variable expansion; generating many separate includes
	    # seems safest.
	    $output_rules .= "\n";
	    foreach $iter (@deplist)
 	    {
		$output_rules .= "\@AMDEP\@" . 'include ' . $iter . "\n";
	    }

	    $output_rules .= &file_contents ('depend');
	    &depend ('clean', 'depend');
	    &push_phony_cleaners ('depend');
	}
    }
    else
    {
	&define_variable ('depcomp', '');
    }

    local ($key, $lang, $ext, $xform);
    foreach $key (sort keys %language_map)
    {
	next unless $key =~ /^(.*)-autodep$/;
	next if $language_map{$key} eq 'no';
	&add_depend2 ($1);
    }
}

# Handle subdirectories.
sub handle_subdirs
{
    return if ! &variable_defined ('SUBDIRS');

    # Make sure each directory mentioned in SUBDIRS actually exists.
    local ($dir);
    foreach $dir (&variable_value_as_list ('SUBDIRS', 'all'))
    {
	# Skip directories substituted by configure.
	next if $dir =~ /^\@.*\@$/;

	if (! -d $am_relative_dir . '/' . $dir)
	{
	    &am_line_error ('SUBDIRS',
			    "required directory $am_relative_dir/$dir does not exist");
	    next;
	}

	&am_line_error ('SUBDIRS', "directory should not contain \`/'")
	    if $dir =~ /\//;
    }

    local ($xform) = ('s/\@INSTALLINFO\@/' .
		      (defined $options{'no-installinfo'}
		       ? 'install-info-recursive'
		       : '')
		      . '/;');
    $output_rules .= &file_contents ('subdirs', $xform);
    &push_phony_cleaners ('recursive');

    $recursive_install = 1;
}

# Handle aclocal.m4.
sub handle_aclocal_m4
{
    local ($regen_aclocal) = 0;
    if (-f 'aclocal.m4')
    {
	&define_variable ("ACLOCAL_M4", '$(top_srcdir)/aclocal.m4');
	&push_dist_common ('aclocal.m4');

	if (open (ACLOCAL, '< aclocal.m4'))
	{
	    local ($line);
	    $line = <ACLOCAL>;
	    close (ACLOCAL);

	    if ($line =~ 'generated automatically by aclocal')
	    {
		$regen_aclocal = 1;
	    }
	}
    }

    local ($acinclude) = 0;
    if (-f 'acinclude.m4')
    {
	$regen_aclocal = 1;
	$acinclude = 1;
    }

    # Note that it might be possible that aclocal.m4 doesn't exist but
    # should be auto-generated.  This case probably isn't very
    # important.
    if ($regen_aclocal)
    {
	local (@ac_deps) = (
			    ($seen_maint_mode
			     ? "\@MAINTAINER_MODE_TRUE\@"
			     : "") ,
			    $configure_ac,
			    ($acinclude ? ' acinclude.m4' : '')
			    );

	if (&variable_defined ('ACLOCAL_M4_SOURCES'))
	{
	    push (@ac_deps, "\$(ACLOCAL_M4_SOURCES)");
	}
	elsif (&variable_defined ('ACLOCAL_AMFLAGS'))
	{
	    # Scan all -I directories for m4 files.  These are our
	    # dependencies.
	    local ($examine_next, $amdir) = 0;
	    foreach $amdir (&variable_value_as_list ('ACLOCAL_AMFLAGS', ''))
	    {
		if ($examine_next)
		{
		    $examine_next = 0;
		    if ($amdir !~ /^\// && -d $amdir)
		    {
			foreach $ac_dep (&my_glob ($amdir . '/*.m4'))
			{
			    $ac_dep =~ s/^\.\/+//;
			    push (@ac_deps, $ac_dep)
				unless $ac_dep eq "aclocal.m4"
				    || $ac_dep eq "acinclude.m4";
			}
		    }
		}
		elsif ($amdir eq '-I')
		{
		    $examine_next = 1;
		}
	    }
	}

	&pretty_print_rule ("\$(ACLOCAL_M4):", "\t\t", @ac_deps);

	$output_rules .=  ("\t"
			   . 'cd $(srcdir) && $(ACLOCAL)'
			   . (&variable_defined ('ACLOCAL_AMFLAGS')
			      ? ' $(ACLOCAL_AMFLAGS)' : '')
			   . "\n");
    }
}

# Rewrite a list of input files into a form suitable to put on a
# dependency list.  The idea is that if an input file has a directory
# part the same as the current directory, then the directory part is
# simply removed.  But if the directory part is different, then
# $(top_srcdir) is prepended.  Among other things, this is used to
# generate the dependency list for the output files generated by
# AC_OUTPUT.  Consider what the dependencies should look like in this
# case:
#   AC_OUTPUT(src/out:src/in1:lib/in2)
# The first argument, ADD_SRCDIR, is 1 if $(top_srcdir) should be added.
# If 0 then files that require this addition will simply be ignored.
sub rewrite_inputs_into_dependencies
{
    local ($add_srcdir, @inputs) = @_;
    local ($single, @newinputs);

    foreach $single (@inputs)
    {
	if (&dirname ($single) eq $relative_dir)
	{
	    push (@newinputs, &basename ($single));
	}
	elsif ($add_srcdir)
	{
	    push (@newinputs, '$(top_srcdir)/' . $single);
	}
    }

    return @newinputs;
}

# Handle remaking and configure stuff.
# We need the name of the input file, to do proper remaking rules.
sub handle_configure
{
    local ($local, $input, @secondary_inputs) = @_;

    local ($top_reldir);

    local ($input_base) = &basename ($input);
    local ($local_base) = &basename ($local);

    local ($amfile) = $input_base . '.am';
    # We know we can always add '.in' because it really should be an
    # error if the .in was missing originally.
    local ($infile) = '$(srcdir)/' . $input_base . '.in';
    local ($colon_infile);
    if ($local ne $input || @secondary_inputs)
    {
	$colon_infile = ':' . $input . '.in';
    }
    $colon_infile .= ':' . join (':', @secondary_inputs)
	if @secondary_inputs;

    local (@rewritten) = &rewrite_inputs_into_dependencies (1,
							    @secondary_inputs);

    # This rule remakes the Makefile.in.  Note use of
    # @MAINTAINER_MODE_TRUE@ forces us to abandon pretty-printing.
    # Sigh.
    $output_rules .= ($infile
		      # NOTE perl 5.003 (with -w) gives a
		      # uninitialized value error on the next line.
		      # Don't know why.
		      . ': '
		      . ($seen_maint_mode ? "\@MAINTAINER_MODE_TRUE\@ " : '')
		      . $amfile . ' '
		      . '$(top_srcdir)/' . $configure_ac .' $(ACLOCAL_M4)'
                      . ' ' . join (' ', @include_stack)
                      . "\n"
		      . "\tcd \$(top_srcdir) && \$(AUTOMAKE) "
		      . ($cygnus_mode ? '--cygnus' : ('--' . $strictness_name))
		      . ($cmdline_use_dependencies ? '' : ' --ignore-deps')
		      . ' ' . $input . $colon_infile . "\n\n");

    # This rule remakes the Makefile.
    $output_rules .= ($local_base
		      # NOTE: bogus uninit value error on next line;
		      # see comment above.
		      . ': '
		      . $infile . ' '
		      . join (' ', @rewritten)
		      . ' $(top_builddir)/config.status'
		      . "\n"
		      . "\tcd \$(top_builddir) \\\n"
		      . "\t  && CONFIG_FILES="
		      . (($relative_dir eq '.') ? '$@' : '$(subdir)/$@')
		      . $colon_infile
		      . ' CONFIG_HEADERS= CONFIG_LINKS= CONFIG_COMMANDS= $(SHELL) ./config.status'
		      . "\n\n");

    if ($relative_dir ne '.')
    {
	# In subdirectory.
	$top_reldir = '../';
    }
    else
    {
        local ($xform) = &transform ('CONFIGURE_AC' => $configure_ac);
	&handle_aclocal_m4;
	$output_rules .= &file_contents ('remake', $xform);
	&examine_variable ('CONFIG_STATUS_DEPENDENCIES');
	&examine_variable ('CONFIGURE_DEPENDENCIES');
	$top_reldir = '';

	&push_dist_common ('acconfig.h')
	    if -f 'acconfig.h';
    }

    # If we have a configure header, require it.
    local ($one_hdr);
    local (@local_fullnames) = @config_fullnames;
    local (@local_names) = @config_names;
    local ($hdr_index) = 0;
    local ($distclean_config) = '';
    foreach $one_hdr (@config_headers)
    {
	local ($one_fullname) = shift (@local_fullnames);
	local ($one_name) = shift (@local_names);
	$hdr_index += 1;
	local ($header_dir) = &dirname ($one_name);

	# If the header is in the current directory we want to build
	# the header here.  Otherwise, if we're at the topmost
	# directory and the header's directory doesn't have a
	# Makefile, then we also want to build the header.
	if ($relative_dir eq $header_dir
	    || ($relative_dir eq '.' && ! &is_make_dir ($header_dir)))
	{
	    local ($ch_sans_dir, $cn_sans_dir, $stamp_dir);
	    if ($relative_dir eq $header_dir)
	    {
		$cn_sans_dir = &basename ($one_name);
		$stamp_dir = '';
	    }
	    else
	    {
		$cn_sans_dir = $one_name;
		if ($header_dir eq '.')
		{
		    $stamp_dir = '';
		}
		else
		{
		    $stamp_dir = $header_dir . '/';
		}
	    }

	    # Compute relative path from directory holding output
	    # header to directory holding input header.  FIXME:
	    # doesn't handle case where we have multiple inputs.
	    if (&dirname ($one_hdr) eq $relative_dir)
	    {
		$ch_sans_dir = &basename ($one_hdr);
	    }
	    else
	    {
		local (@rel_out_path);
		# FIXME this chunk of code should be its own sub.
		# It is used elsewhere.
		foreach (split (/\//, $relative_dir))
		{
		    next if $_ eq '' || $_ eq '.';
		    if ($_ eq '..')
		    {
			# FIXME: actually this is an error.
			pop @rel_out_path;
		    }
		    else
		    {
			push (@rel_out_path, '..');
		    }
		}
		if (@rel_out_path)
		{
		    $ch_sans_dir = join ('/', @rel_out_path) . '/' . $one_hdr;
		}
		else
		{
		    $ch_sans_dir = $one_hdr;
		}
	    }

	    &require_file_with_conf_line ($config_header_line,
					  $FOREIGN, $ch_sans_dir);

	    # Header defined and in this directory.
	    local (@files);
	    if (-f $one_name . '.top')
	    {
		push (@files, "${cn_sans_dir}.top");
	    }
	    if (-f $one_name . '.bot')
	    {
		push (@files, "${cn_sans_dir}.bot");
	    }

	    &push_dist_common (@files);

	    # For now, acconfig.h can only appear in the top srcdir.
	    if (-f 'acconfig.h')
	    {
		if ($relative_dir eq '.')
		{
		    push (@files, 'acconfig.h');
		}
		else
		{
		    # Strange quoting because this gets fed through
		    # Perl.
		    push (@files, '\$(top_srcdir)/acconfig.h');
		}
	    }

	    local ($stamp_name) = 'stamp-h';
	    $stamp_name .= "${hdr_index}" if scalar (@config_headers) > 1;

	    local ($xform) = '';

	    $xform = &transform ('CONFIGURE_AC'       => $configure_ac,
				 'FILES'              => join (' ', @files),
				 'CONFIG_HEADER'      => $cn_sans_dir,
				 'CONFIG_HEADER_IN'   => $ch_sans_dir,
				 'CONFIG_HEADER_FULL' => $one_fullname,
				 'STAMP'          => "$stamp_dir$stamp_name");

	    local ($out_dir) = &dirname ($ch_sans_dir);
	    $xform .= &transform ('SRC_STAMP' => "${out_dir}/${stamp_name}");
	    $output_rules .= &file_contents ('remake-hdr', $xform);

	    &create ("${relative_dir}/${out_dir}/${stamp_name}.in");
	    &require_file_with_conf_line ($config_header_line, $FOREIGN,
					  "${out_dir}/${stamp_name}.in");

	    $distclean_config .= ' ' if $distclean_config;
	    $distclean_config .= $cn_sans_dir;
	}
    }

    if ($distclean_config)
    {
	$output_rules .=
	    &file_contents ('clean-hdr',
			    &transform ('FILES' => $distclean_config));
	&depend ('clean', 'hdr');
	&push_phony_cleaners ('hdr');
    }

    # Set location of mkinstalldirs.
    if ($config_aux_dir ne '.' && $config_aux_dir ne '')
    {
	&define_variable ('mkinstalldirs', ('$(SHELL) ' . $config_aux_dir
					    . '/mkinstalldirs'));
    }
    else
    {
	&define_variable ('mkinstalldirs',
			  '$(SHELL) $(top_srcdir)/mkinstalldirs');
    }

    &am_line_error ('CONFIG_HEADER',
		    "\`CONFIG_HEADER' is an anachronism; now determined from \`$configure_ac'")
	if &variable_defined ('CONFIG_HEADER');

    local ($one_name);
    local ($config_header) = '';
    foreach $one_name (@config_names)
    {
	# Generate CONFIG_HEADER define.
	local ($one_hdr);
	if ($relative_dir eq &dirname ($one_name))
	{
	    $one_hdr = &basename ($one_name);
	}
	else
	{
	    $one_hdr = "${top_builddir}/${one_name}";
	}

	$config_header .= ' ' if $config_header;
	$config_header .= $one_hdr;
    }
    if ($config_header)
    {
	&define_variable ("CONFIG_HEADER", $config_header);
    }

    # Now look for other files in this directory which must be remade
    # by config.status, and generate rules for them.
    local (@actual_other_files) = ();
    local ($file, $local);
    local (@inputs, @rewritten_inputs, $single);
    local ($need_rewritten, $lfile);
    foreach $lfile (@other_input_files)
    {
	if ($lfile =~ /^([^:]*):(.*)$/)
	{
	    # This is the ":" syntax of AC_OUTPUT.
	    $file = $1;
	    $local = &basename ($file);
	    @inputs = split (':', $2);
	    @rewritten_inputs = &rewrite_inputs_into_dependencies (1, @inputs);
	    $need_rewritten = 1;
	}
	else
	{
	    # Normal usage.
	    $file = $lfile;
	    $local = &basename ($file);
	    @inputs = ($local . '.in');
	    @rewritten_inputs =
		&rewrite_inputs_into_dependencies (1, $file . '.in');
	    $need_rewritten = 0;
	}

	# Make sure the dist directory for each input file is created.
	# We only have to do this at the topmost level though.  This
	# is a bit ugly but it easier than spreading out the logic,
	# especially in cases like AC_OUTPUT(foo/out:bar/in), where
	# there is no Makefile in bar/.
	if ($relative_dir eq '.')
	{
	    foreach (@inputs)
	    {
		$dist_dirs{&dirname ($_)} = 1;
	    }
	}

	# Skip files not in this directory.
	next unless &dirname ($file) eq $relative_dir;

	# Skip any file that is an automake input.
	next if -f $file . '.am';

	# Some users have been tempted to put `stamp-h' in the
	# AC_OUTPUT line.  This won't do the right thing, so we
	# explicitly fail here.
	if ($local eq 'stamp-h')
	{
	    # FIXME: allow real filename.
	    &am_conf_error ($configure_ac, $ac_output_line,
			    'stamp-h should not appear in AC_OUTPUT');
	    next;
	}

	$output_rules .= ($local . ': '
			  . '$(top_builddir)/config.status '
			  . join (' ', @rewritten_inputs) . "\n"
			  . "\t"
			  . 'cd $(top_builddir) && CONFIG_FILES='
			  . ($relative_dir eq '.' ? '' : '$(subdir)/')
   			  . '$@' . ($need_rewritten
				    ? (':' . join (':', @inputs))
				    : '')
			  . ' CONFIG_HEADERS= CONFIG_LINKS= CONFIG_COMMANDS= $(SHELL) ./config.status'
			  . "\n");
	push (@actual_other_files, $local);

	# Require all input files.
	&require_file_with_conf_line ($ac_output_line, $FOREIGN,
				      &rewrite_inputs_into_dependencies (0, @inputs));
    }

    # These files get removed by "make clean".
    &define_pretty_variable ('CONFIG_CLEAN_FILES', '', @actual_other_files);
}

# Handle C headers.
sub handle_headers
{
    local (@r);
    @r = &am_install_var ('-defaultdist', 'header', 'HEADERS', 'include',
			  'oldinclude', 'pkginclude',
			  'noinst', 'check');
    foreach (@r)
    {
	next unless /\.(.*)$/;
	&saw_extension ($1);
    }
}

sub handle_gettext
{
    return if ! $seen_gettext || $relative_dir ne '.';

    if (! &variable_defined ('SUBDIRS'))
    {
	&am_conf_error
	    ("AM_GNU_GETTEXT used but SUBDIRS not defined");
	return;
    }

    &require_file_with_conf_line ($ac_gettext_line, $GNU, 'ABOUT-NLS');

    if (&variable_defined ('SUBDIRS'))
    {
	&am_line_error
	    ('SUBDIRS',
	     "AM_GNU_GETTEXT in \`$configure_ac' but \`po' not in SUBDIRS")
		if $contents{'SUBDIRS'} !~ /\bpo\b/;
	&am_line_error
	    ('SUBDIRS',
	     "AM_GNU_GETTEXT in \`$configure_ac' but \`intl' not in SUBDIRS")
		if $contents{'SUBDIRS'} !~ /\bintl\b/;
    }

    # Ensure that each language in ALL_LINGUAS has a .po file, and
    # each po file is mentioned in ALL_LINGUAS.
    if ($seen_linguas)
    {
	local (%linguas) = ();
	grep ($linguas{$_} = 1, split (' ', $all_linguas));

	foreach (<po/*.po>)
	{
	    s/^po\///;
	    s/\.po$//;

	    &am_line_error ($all_linguas_line,
			    ("po/$_.po exists but \`$_' not in \`ALL_LINGUAS'"))
		if ! $linguas{$_};
	}

	foreach (keys %linguas)
	{
	    &am_line_error ($all_linguas_line,
			    "$_ in \`ALL_LINGUAS' but po/$_.po does not exist")
		if ! -f "po/$_.po";
	}
    }
    else
    {
	&am_error ("AM_GNU_GETTEXT in \`$configure_ac' but \`ALL_LINGUAS' not defined");
    }
}

# Handle footer elements.
sub handle_footer
{
    if ($contents{'SOURCES'})
    {
	# NOTE don't use define_pretty_variable here, because
	# $contents{...} is already defined.
	$output_vars .= 'SOURCES = ' . $contents{'SOURCES'} . "\n";
    }
    if ($contents{'OBJECTS'})
    {
	# NOTE don't use define_pretty_variable here, because
	# $contents{...} is already defined.
	$output_vars .= 'OBJECTS = ' . $contents{'OBJECTS'} . "\n";
    }
    if ($contents{'SOURCES'} || $contents{'OBJECTS'})
    {
	$output_vars .= "\n";
    }

    if (&target_defined ('.SUFFIXES'))
    {
	&am_line_error ('.SUFFIXES',
			"use variable \`SUFFIXES', not target \`.SUFFIXES'");
    }

    # Note: AIX 4.1 /bin/make will fail if any suffix rule appears
    # before .SUFFIXES.  So we make sure that .SUFFIXES appears before
    # anything else, by sticking it right after the default: target.
    $output_header .= ".SUFFIXES:\n";
    if (@suffixes || &variable_defined ('SUFFIXES'))
    {
	# Make sure suffixes has unique elements.  Sort them to ensure
	# the output remains consistent.  However, $(SUFFIXES) is
	# always at the start of the list, unsorted.  This is done
	# because make will choose rules depending on the ordering of
	# suffixes, and this lets the user have some control.  Push
	# actual suffixes, and not $(SUFFIXES).  Some versions of make
	# do not like variable substitutions on the .SUFFIXES line.
	local (%suffixes);
	local (@user_suffixes) = (&variable_defined ('SUFFIXES')
				  ? &variable_value_as_list ('SUFFIXES', '')
				  : ());

	grep ($suffixes{$_} = 1, @suffixes);
	delete @suffixes{@user_suffixes};

	$output_header .= (".SUFFIXES: "
			   . join (' ', @user_suffixes, sort keys %suffixes)
			   . "\n");
    }
    $output_trailer .= &file_contents ('footer');
}

# Deal with installdirs target.
sub handle_installdirs
{
    # GNU Makefile standards recommend this.
    if ($recursive_install)
    {
	# We create a separate `-am' target so that the -recursive
	# rule will work correctly.
	$output_rules .= ("installdirs: installdirs-recursive\n"
			  . "installdirs-am:\n");
	&depend ('.PHONY', 'installdirs-am');
    }
    else
    {
	$output_rules .= "installdirs:\n";
    }
    &depend ('.PHONY', 'installdirs');
    if (@installdirs)
    {
	&pretty_print_rule ("\t" . '$(mkinstalldirs) ', "\t\t",
			    @installdirs);
    }
    $output_rules .= "\n";
}

# There are several targets which need to be merged.  This is because
# their complete definition is compiled from many parts.  Note that we
# avoid double colon rules, otherwise we'd use them instead.
sub handle_merge_targets
{
    local ($makefile) = @_;

    # There are a few install-related variables that you should not define.
    local ($var);
    foreach $var ('PRE_INSTALL', 'POST_INSTALL', 'NORMAL_INSTALL')
    {
	if (&variable_defined ($var))
	{
	    &am_line_error ($var, "\`$var' should not be defined");
	}
    }

    # Put this at the beginning for the sake of non-GNU makes.  This
    # is still wrong if these makes can run parallel jobs.  But it is
    # right enough.
    unshift (@all, &basename ($makefile));

    local ($one_name);
    foreach $one_name (@config_names)
    {
	push (@all, &basename ($one_name))
	    if &dirname ($one_name) eq $relative_dir;
    }

    &do_one_merge_target ('info', @info);
    &do_one_merge_target ('dvi', @dvi);
    &do_check_merge_target;
    &do_one_merge_target ('installcheck', @installcheck);

    if (defined $options{'no-installinfo'})
    {
	&do_one_merge_target ('install-info', '');
    }
    elsif (&target_defined ('install-info-local'))
    {
	&am_line_error ('install-info-local',
			"\`install-info-local' target defined but \`no-installinfo' option not in use");
    }

    local ($utarg);
    foreach $utarg ('uninstall-data-local', 'uninstall-data-hook',
		    'uninstall-exec-local', 'uninstall-exec-hook')
    {
	if (&target_defined ($utarg))
	{
	    local ($x);
	    ($x = $utarg) =~ s/(data|exec)-//;
	    &am_line_error ($utarg, "use \`$x', not \`$utarg'");
	}
    }

    if (&target_defined ('install-local'))
    {
	&am_line_error ('install-local',
			"use \`install-data-local' or \`install-exec-local', not \`install-local'");
    }

    if (@all || &variable_defined ('BUILT_SOURCES'))
    {
	local ($one_name);
	local ($local_headers) = '';
	$local_headers = '$(BUILT_SOURCES)'
	    if &variable_defined ('BUILT_SOURCES');
	foreach $one_name (@config_names)
	{
	    if (&dirname ($one_name) eq $relative_dir)
	    {
		$local_headers .= ' ' if $local_headers;
		$local_headers .= &basename ($one_name);
	    }
	}
	if ($local_headers)
	{
	    # This is kind of a hack, but I couldn't see a better way
	    # to handle it.  In this particular case, we need to make
	    # sure config.h is built before we recurse.  We can't do
	    # this by changing the order of dependencies to the "all"
	    # because that breaks when using parallel makes.  Instead
	    # we handle things explicitly.
	    $output_rules .= ("all-recursive-am: ${local_headers}"
				  . "\n\t"
				  . '$(MAKE) $(AM_MAKEFLAGS)'
				  . " all-recursive"
				  . "\n\n");
	    $all_target = 'all-recursive-am';
	    &depend ('.PHONY', 'all-recursive-am');
	}
    }

    if (&variable_defined('lib_LTLIBRARIES') &&
	&variable_defined('bin_PROGRAMS'))
    {
	$output_rules .= "install-binPROGRAMS: install-libLTLIBRARIES\n\n";
    }
    # Print definitions users can use.
    &do_one_merge_target ('install-exec', @install_exec);
    $output_rules .= "\n";

    &do_one_merge_target ('install-data', @install_data);
    $output_rules .= "\n";

    &do_one_merge_target ('install', 'all-am');
    &do_one_merge_target ('uninstall', @uninstall);

    &do_one_merge_target ('all', @all);

    # Generate the new 'install-strip' target.  We can't just set
    # INSTALL_PROGRAM because that might be a relative path.
    $output_rules .= ("install-strip:\n\t"
		      . '$(MAKE) $(AM_MAKEFLAGS) INSTALL_STRIP_FLAG=-s install'
		      . "\n");
    &depend ('.PHONY', 'install-strip');
}

# Helper for handle_merge_targets.  Note that handle_merge_targets
# relies on the fact that this doesn't add an extra \n at the end.
sub do_one_merge_target
{
    local ($name, @values) = @_;

    if (&target_defined ($name . '-local'))
    {
	# User defined local form of target.  So include it.
	push (@values, $name . '-local');
	&depend ('.PHONY', $name . '-local');
    }

    &pretty_print_rule ($name . "-am:", "\t\t", @values);
    if ($name eq 'install')
    {
	# Special-case `install-am' to run install-exec-am and
	# install-data-am after all-am is built.
	&pretty_print_rule ("\t\@\$(MAKE) \$(AM_MAKEFLAGS)", "\t  ",
			    'install-exec-am', 'install-data-am');
    }
    elsif ($name eq 'install-exec' && &target_defined ('install-exec-hook'))
    {
	$output_rules .= ("\t\@\$(NORMAL_INSTALL)\n"
			  . "\t" . '$(MAKE) $(AM_MAKEFLAGS) install-exec-hook'
			  . "\n");
    }
    elsif ($name eq 'install-data' && &target_defined ('install-data-hook'))
    {
	$output_rules .= ("\t\@\$(NORMAL_INSTALL)\n"
			  . "\t" . '$(MAKE) $(AM_MAKEFLAGS) install-data-hook'
			  . "\n");
    }

    local ($lname) = $name . ($recursive_install ? '-recursive' : '-am');
    local ($tname) = $name;
    # To understand this special case, see handle_merge_targets.
    if ($name eq 'all')
    {
	$tname = 'all-redirect';
	$lname = $all_target if $recursive_install;
	&depend ('.PHONY', 'all-redirect');
	$output_all = "all: all-redirect\n";
    }
    &pretty_print_rule ($tname . ":", "\t\t", $lname);
    &depend ('.PHONY', $name . '-am', $name);
}

# Handle check merge target specially.
sub do_check_merge_target
{
    if (&target_defined ('check-local'))
    {
	# User defined local form of target.  So include it.
	push (@check_tests, 'check-local');
	&depend ('.PHONY', 'check-local');
    }

    # In --cygnus mode, check doesn't depend on all.
    if ($cygnus_mode)
    {
	# Just run the local check rules.
	&pretty_print_rule ('check-am:', "\t\t", @check);
    }
    else
    {
	# The check target must depend on the local equivalent of
	# `all', to ensure all the primary targets are built.  Then it
	# must build the local check rules.
	$output_rules .= "check-am: all-am\n";
	&pretty_print_rule ("\t\$(MAKE) \$(AM_MAKEFLAGS)", "\t  ",
			    @check)
	    if @check;
    }
    &pretty_print_rule ("\t\$(MAKE) \$(AM_MAKEFLAGS)", "\t  ",
			@check_tests)
	if @check_tests;

    &depend ('.PHONY', 'check', 'check-am');
    $output_rules .= ("check: "
		      . ($recursive_install ? 'check-recursive' : 'check-am')
		      . "\n");
}

# Handle all 'clean' targets.
sub handle_clean
{
    local ($xform) = '';
    local ($name);

    # Don't include `MAINTAINER'; it is handled specially below.
    foreach $name ('MOSTLY', '', 'DIST')
    {
	if (! &variable_defined ($name . 'CLEANFILES'))
	{
	    $xform .= 's/^' . $name . 'CLEAN.*$//;';
	}
	else
	{
	    $xform .= 's/^' . $name . 'CLEAN//;';
	}
    }

    # Built sources are automatically removed by maintainer-clean.
    push (@maintainer_clean_files, '\$(BUILT_SOURCES)')
	if &variable_defined ('BUILT_SOURCES');
    push (@maintainer_clean_files, '\$(MAINTAINERCLEANFILES)')
	if &variable_defined ('MAINTAINERCLEANFILES');
    if (! @maintainer_clean_files)
    {
	$xform .= 's/^MAINTAINERCLEAN.*$//;';
    }
    else
    {
	$xform .= ('s/^MAINTAINERCLEAN//;'
		   # Join with no space to avoid spurious `test -z'
		   # success at runtime.
		   . 's,\@MCFILES\@,' . join ('', @maintainer_clean_files)
		   . ',;'
		   # A space is required in the join here.
		   . 's,\@MFILES\@,' . join (' ', @maintainer_clean_files)
		   . ',;');
    }

    $output_rules .= &file_contents ('clean', $xform);

    &depend ('clean', 'generic');
    &push_phony_cleaners ('generic');

    &do_one_clean_target ('mostly', '');
    &do_one_clean_target ('', 'mostly');
    &do_one_clean_target ('dist', '');
    &do_one_clean_target ('maintainer-', 'dist');

    &depend ('.PHONY',
	     'clean', 'mostlyclean', 'distclean', 'maintainer-clean');
}


# &do_one_clean_target ($NAME, $LAST_NAME)
# ----------------------------------------
# Helper for handle_clean.
sub do_one_clean_target
{
    my ($name, $last_name) = @_;
    my (@deps) = @{$dependencies{'clean'}};

    # Change each dependency `BLARG' into `clean-BLARG'.
    grep (($_ = $name . 'clean-' . $_) && 0, @deps);

    # Push the previous clean target.  There is no previous clean
    # target if we're doing mostlyclean.
    push (@deps, $last_name . 'clean-am')
	unless $name eq 'mostly';

    # If a -local version of the rule is given, add it to the list.
    if (&target_defined ($name . 'clean-local'))
    {
	push (@deps, $name . 'clean-local');
    }

    # Print the target and the dependencies.
    &pretty_print_rule ($name . 'clean-am: ', "\t\t", @deps);

    # FIXME: shouldn't we really print these messages before running
    # the dependencies?
    if ($name eq 'maintainer-')
    {
	# Print a special warning.
	$output_rules .=
	    ("\t\@echo \"This command is intended for maintainers to use;\"\n"
	     . "\t\@echo \"it deletes files that may require special "
	     . "tools to rebuild.\"\n");
    }
    elsif ($name eq 'dist')
    {
	$output_rules .= "\t-rm -f libtool\n" if $seen_libtool;
    }
    $output_rules .= "\n";

    # Now generate the actual clean target.
    $output_rules .= ($name . 'clean' . ": " . $name . 'clean'
		      . ($recursive_install ? '-recursive' : '-am')
		      . "\n");

    # We special-case config.status here.  If we do it as part of the
    # normal clean processing for this directory, then it might be
    # removed before some subdir is cleaned.  However, that subdir's
    # Makefile depends on config.status.
    if (($name eq 'maintainer-'
	 || $name eq 'dist')
	&& $relative_dir eq '.')
    {
	$output_rules .= "\t-rm -f config.status\n";
    }
    $output_rules .= "\n";
}


# &depend ($CATEGORY, @DEPENDENDEES)
# ----------------------------------
sub depend
{
    my ($category, @dependendees) = @_;
    {
      push (@{$dependencies{$category}}, @dependendees);
    }
}



# &handle_factored_dependencies ()
# --------------------------------
# Handle .PHONY target.
sub handle_factored_dependencies
{
    my $category;
    foreach $category (sort keys %dependencies)
    {
        # FIXME: For the time being, there are targets which we
        # handle specifically.  When all the clean targets stick to
        # this scheme, it should be possible to avoid these special cases.
        next
	  if $category =~ /^(clean)$/;
        &pretty_print_rule ("$category:", "",
			    sort @{$dependencies{$category}});
        $output_rules .= "\n";
    }
}


# &handle_tests_dejagnu ()
# ------------------------
sub handle_tests_dejagnu
{
    push (@check_tests, 'check-DEJAGNU');

    local ($xform);
    if ($cygnus_mode)
    {
        $xform = 's/^CYGNUS//;';
    }
    else
    {
        $xform = 's/^CYGNUS.*$//;';
    }
    $output_rules .= &file_contents ('dejagnu', $xform);

    # In Cygnus mode, these are found in the build tree.
    # Otherwise they are looked for in $PATH.
    &define_program_variable ('EXPECT', 'build', 'expect', 'expect');
    &define_program_variable ('RUNTEST', 'src', 'dejagnu', 'runtest');

    # Only create site.exp rule if user hasn't already written
    # one.
    if (! &target_defined ('site.exp'))
    {
        # Note that in the rule we don't directly generate
        # site.exp to avoid the possibility of a corrupted
        # site.exp if make is interrupted.  Jim Meyering has some
        # useful text on this topic.
        $output_rules .= ("site.exp: Makefile\n"
                          . "\t\@echo 'Making a new site.exp file...'\n"
                          . "\t\@test ! -f site.bak || rm -f site.bak\n"
                          . "\t\@echo '## these variables are automatically generated by make ##' > \$\@-t\n"
                          . "\t\@echo '# Do not edit here.  If you wish to override these values' >> \$\@-t\n"
                          . "\t\@echo '# edit the last section' >> \$\@-t\n"
                          . "\t\@echo 'set tool \$(DEJATOOL)' >> \$\@-t\n"
                          . "\t\@echo 'set srcdir \$(srcdir)' >> \$\@-t\n"
                          . "\t\@echo 'set objdir' \`pwd\` >> \$\@-t\n");

        # Extra stuff for AC_CANONICAL_*
        local (@whatlist) = ();
        if ($seen_canonical)
        {
            push (@whatlist, 'host');
        }

        # Extra stuff only for AC_CANONICAL_SYSTEM.
        if ($seen_canonical == $AC_CANONICAL_SYSTEM)
        {
            push (@whatlist, 'target', 'build');
        }

        local ($c1, $c2);
        foreach $c1 (@whatlist)
        {
            foreach $c2 ('alias', 'triplet')
            {
                $output_rules .= "\t\@echo 'set ${c1}_${c2} \$(${c1}_${c2})' >> \$\@-t\n";
            }
        }

        $output_rules .= ("\t\@echo '## All variables above are generated by configure. Do Not Edit ##' >> \$\@-t\n"
                          . "\t\@test ! -f site.exp || sed '1,/^## All variables above are.*##/ d' site.exp >> \$\@-t\n"
                          . "\t\@test ! -f site.exp || mv site.exp site.bak\n"
                          . "\t\@mv \$\@-t site.exp\n");
    }
}


# Handle TESTS variable and other checks.
sub handle_tests
{
    if (defined $options{'dejagnu'})
    {
        &handle_tests_dejagnu;
    }
    else
    {
	local ($c);
	foreach $c ('DEJATOOL', 'RUNTEST', 'RUNTESTFLAGS')
	{
	    if (&variable_defined ($c))
	    {
		&am_line_error ($c, "\`$c' defined but \`dejagnu' not in \`AUTOMAKE_OPTIONS'");
	    }
	}
    }

    if (&variable_defined ('TESTS'))
    {
	push (@check_tests, 'check-TESTS');

	# Note: Solaris 2.7 seems to expand TESTS using VPATH.  That's
	# why we also try `dir='
	$output_rules .= &file_contents ('check');
    }
}

# Handle Emacs Lisp.
sub handle_emacs_lisp
{
    local (@elfiles) = &am_install_var ('-candist', 'lisp', 'LISP',
					'lisp', 'noinst');

    if (@elfiles)
    {
	# Found some lisp.
	&define_configure_variable ('lispdir');
	&define_configure_variable ('EMACS');
	$output_rules .= (".el.elc:\n"
			  . "\t\@echo 'WARNING: Warnings can be ignored. :-)'\n"
			  . "\tif test \$(EMACS) != no; then \\\n"
			  . "\t  EMACS=\$(EMACS) \$(SHELL) \$(srcdir)/elisp-comp \$<; \\\n"
			  . "\tfi\n");
	push (@suffixes, '.el', '.elc');

	# Generate .elc files.
	grep ($_ .= 'c', @elfiles);
	&define_pretty_variable ('ELCFILES', '', @elfiles);

	$output_rules .= &file_contents ('lisp-clean');
	&depend ('clean', 'lisp');
	&push_phony_cleaners ('lisp');

	push (@all, '$(ELCFILES)');

	local ($varname);
	if (&variable_defined ('lisp_LISP'))
	{
	    $varname = 'lisp_LISP';
	    &am_error ("\`lisp_LISP' defined but \`AM_PATH_LISPDIR' not in \`$configure_ac'")
		if ! $seen_lispdir;
	}
	else
	{
	    $varname = 'noinst_LISP';
	}

	&require_file_with_line ($varname, $FOREIGN, 'elisp-comp');
    }
}

# Handle Python
sub handle_python
{
    local (@pyfiles) = &am_install_var ('-defaultdist', 'python', 'PYTHON',
					'python', 'noinst');
    return if ! @pyfiles;

    # Found some python.
    &define_configure_variable ('pythondir');
    &define_configure_variable ('PYTHON');

    $output_rules .= &file_contents ('python-clean');
    &depend ('clean', 'python');

    &am_error ("\`python_PYTHON' defined but \`AM_CHECK_PYTHON' not in \`$configure_ac'")
	if ! $seen_pythondir && &variable_defined ('python_PYTHON');

    if ($config_aux_dir eq '.' || $config_aux_dir eq '')
    {
	&define_variable ('py_compile', '$(top_srcdir)/py-compile');
    }
    else
    {
	&define_variable ('py_compile', $config_aux_dir . '/py-compile');
    }
}

# Handle Java.
sub handle_java
{
    local (@sourcelist) = &am_install_var ('-candist', '-clean',
					   'java', 'JAVA',
					   'java', 'noinst', 'check');
    return if ! @sourcelist;

    &define_variable ('JAVAC', 'javac');
    &define_variable ('JAVACFLAGS', '');
    &define_variable ('CLASSPATH_ENV',
		      'CLASSPATH=$(JAVAROOT):$(srcdir)/$(JAVAROOT):$$CLASSPATH');
    &define_variable ('JAVAROOT', '$(top_builddir)');

    local (%valid) = &am_primary_prefixes ('JAVA', 1,
					   'java', 'noinst', 'check');

    local ($dir, $curs);
    foreach $curs (keys %valid)
    {
	if (! &variable_defined ($curs . '_JAVA') || $curs eq 'EXTRA')
	{
	    next;
	}

	if (defined $dir)
	{
	    &am_line_error ($curs . '_JAVA',
			    "multiple _JAVA primaries in use");
	}
	$dir = $curs;
    }

    $output_rules .= ('class' . $dir . '.stamp: $(' . $dir . '_JAVA)' . "\n"
		      . "\t" . '$(CLASSPATH_ENV) $(JAVAC) -d $(JAVAROOT) '
		      . '$(JAVACFLAGS) $?' . "\n"
		      . "\t" . 'echo timestamp > class' . $dir . '.stamp'
		      . "\n");
    push (@all, 'class' . $dir . '.stamp');
    &push_dist_common ('$(' . $dir . '_JAVA)');
}

# Handle some of the minor options.
sub handle_minor_options
{
    if (defined $options{'readme-alpha'})
    {
	if ($relative_dir eq '.')
	{
	    if ($package_version !~ /^$GNITS_VERSION_PATTERN$/)
	    {
		# FIXME: allow real filename.
		&am_conf_line_error ($configure_ac,
				     $package_version_line,
				     "version \`$package_version' doesn't follow Gnits standards");
	    }
	    elsif (defined $1 && -f 'README-alpha')
	    {
		# This means we have an alpha release.  See
		# GNITS_VERSION_PATTERN for details.
		&require_file ($FOREIGN, 'README-alpha');
	    }
	}
    }
}

################################################################

# &scan_autoconf_config_files ($CONFIG-FILES)
# -------------------------------------------
# Study $CONFIG-FILES which is the first argument to AC_CONFIG_FILES
# (or AC_OUTPUT).
sub scan_autoconf_config_files
{
    # Look at potential Makefile.am's.
    foreach (split)
    {
        # Must skip empty string for Perl 4.
        next if $_ eq "\\" || $_ eq '';

        # Handle $local:$input syntax.  Note that we ignore
        # every input file past the first, though we keep
        # those around for later.
        local ($local, $input, @rest) = split (/:/);
        if (! $input)
        {
            $input = $local;
        }
        else
        {
            # FIXME: should be error if .in is missing.
            $input =~ s/\.in$//;
        }

        if (-f $input . '.am')
        {
            # We have a file that automake should generate.
            push (@make_input_list, $input);
            $make_list{$input} = join (':', ($local, @rest));
        }
        else
        {
            # We have a file that automake should cause to be
            # rebuilt, but shouldn't generate itself.
            push (@other_input_files, $_);
        }
    }
}


# &scan_autoconf_traces ($FILENAME)
# ---------------------------------
# FIXME: For the time being, we don't care about the FILENAME.
sub scan_autoconf_traces
{
    local ($filename) = @_;
    local (*TRACES);

    local ($traces) = "$ENV{amtraces} ";

    $traces .= ' -t AC_CONFIG_FILES';
    $traces .= ' -t _AC_LIBOBJ_DECL';
    $traces .= ' -t AC_SUBST';

    open (TRACES, "$traces |")
	|| die "automake: couldn't open \`$traces': $!\n";
    print "automake: reading $traces\n" if $verbose;

    while (<TRACES>)
    {
        chomp;
        local ($file, $line, $macro, @args) = split /:/;
	local ($here) = "$file:$line";

	# Alphabetical ordering please.
        if ($macro eq 'AC_CONFIG_FILES')
	{
	    # Look at potential Makefile.am's.
	    &scan_autoconf_config_files ($args[0]);
	}
        elsif ($macro eq '_AC_LIBOBJ_DECL')
	{
	    local ($source) = "$args[0].c";
	    # We should actually also `close' the sources: getopt.c
	    # wants getopt.h etc.  But actually it should be done in the
	    # macro itself, i.e., we have to first fix Autoconf to extend
	    # _AC_LIBOBJ_DECL and use it the in various macros.
	    if (!defined $libsources{$source})
	        {
		    print STDERR "traces: discovered $source\n";
		    $libsources{$source} = $here;
	        }
	}
        elsif ($macro eq 'AC_SUBST')
	{
	    if (!defined $configure_vars{$args[0]})
	        {
		    print STDERR "traces: discovered AC_SUBST($args[0])\n";
		    $configure_vars{$args[0]} = $here;
	        }
	}
    }

    close (TRACES)
      || die "automake: close: $traces: $!\n";
}


# &scan_one_autoconf_file ($FILENAME)
# -----------------------------------
# Scan one file for interesting things.  Subroutine of
# &scan_autoconf_files.
sub scan_one_autoconf_file
{
    local ($filename) = @_;
    local (*CONFIGURE);

    open (CONFIGURE, $filename)
	|| die "automake: couldn't open \`$filename': $!\n";
    print "automake: reading $filename\n" if $verbose;

    while (<CONFIGURE>)
    {
	# Remove comments from current line.
	s/\bdnl\b.*$//;
	s/\#.*$//;

	# Skip macro definitions.  Otherwise we might be confused into
	# thinking that a macro that was only defined was actually
	# used.
	next if /AC_DEFUN/;

	# Follow includes.  This is a weirdness commonly in use at
	# Cygnus and hopefully nowhere else.
	if (/sinclude\((.*)\)/ && -f $1)
	{
	    &scan_one_autoconf_file ($1);
	}

	# Populate libobjs array.
	if (/AC_FUNC_ALLOCA/)
	{
	    $libsources{'alloca.c'} = 1;
	}
	elsif (/AC_FUNC_GETLOADAVG/)
	{
	    $libsources{'getloadavg.c'} = 1;
	}
	elsif (/AC_FUNC_MEMCMP/)
	{
	    $libsources{'memcmp.c'} = 1;
	}
	elsif (/AC_STRUCT_ST_BLOCKS/)
	{
	    $libsources{'fileblocks.c'} = 1;
	}
	elsif (/A[CM]_REPLACE_GNU_GETOPT/)
	{
	    $libsources{'getopt.c'} = 1;
	    $libsources{'getopt1.c'} = 1;
	}
	elsif (/AM_FUNC_STRTOD/)
	{
	    $libsources{'strtod.c'} = 1;
	}
	elsif (/AM_WITH_REGEX/)
	{
	    $libsources{'rx.c'} = 1;
	    $libsources{'rx.h'} = 1;
	    $libsources{'regex.c'} = 1;
	    $libsources{'regex.h'} = 1;
	}
	elsif (/AC_FUNC_MKTIME/)
	{
	    $libsources{'mktime.c'} = 1;
	}
	elsif (/AM_FUNC_ERROR_AT_LINE/)
	{
	    $libsources{'error.c'} = 1;
	    $libsources{'error.h'} = 1;
	}
	elsif (/AM_FUNC_OBSTACK/)
	{
	    $libsources{'obstack.c'} = 1;
	    $libsources{'obstack.h'} = 1;
	}
	elsif (/LIBOBJS="(.*)\s+\$LIBOBJS"/
	       || /LIBOBJS="\$LIBOBJS\s+(.*)"/)
	{
	    foreach $libobj_iter (split (' ', $1))
	    {
		if ($libobj_iter =~ /^(.*)\.o(bj)?$/
		    || $libobj_iter =~ /^(.*)\.\$ac_objext$/
		    || $libobj_iter =~ /^(.*)\.\$\{ac_objext\}$/)
		{
		    $libsources{$1 . '.c'} = 1;
		}
	    }
	}
	elsif (/AC_LIBOBJ\(([^)]+)\)/)
	{
	    $libsources{"$1.c"} = 1;
	}

	if (! $in_ac_replace && s/AC_REPLACE_FUNCS\s*\(\[?//)
	{
	    $in_ac_replace = 1;
	}
	if ($in_ac_replace)
	{
	    $in_ac_replace = 0 if s/[\]\)].*$//;
	    # Remove trailing backslash.
	    s/\\$//;
	    foreach (split)
	    {
		# Need to skip empty elements for Perl 4.
		next if $_ eq '';
		$libsources{$_ . '.c'} = 1;
	    }
	}

	if (/$obsolete_rx/o)
	{
	    local ($hint) = '';
	    if ($obsolete_macros{$1} ne '')
	    {
		$hint = '; ' . $obsolete_macros{$1};
	    }
	    &am_conf_line_error ($filename, $., "\`$1' is obsolete$hint");
	}

	# Process the AC_OUTPUT and AC_CONFIG_FILES macros.
	if (! $in_ac_output && s/AC_(OUTPUT|CONFIG_FILES)\s*\(\[?//)
	{
	    $in_ac_output = 1;
	    $ac_output_line = $.;
	}
	if ($in_ac_output)
	{
	    local ($closing) = 0;
	    if (s/[\]\),].*$//)
	    {
		$in_ac_output = 0;
		$closing = 1;
	    }

	    # Look at potential Makefile.am's.
	    &scan_autoconf_config_files ($_);

	    if ($closing && @make_input_list == 0 && @other_input_files == 0)
	    {
		&am_conf_line_error ($filename, $ac_output_line,
				     "No files mentioned in \`AC_OUTPUT'");
		exit 1;
	    }
	}

	if (/$AC_CONFIG_AUX_DIR_PATTERN/o)
	{
	    @config_aux_path = $1;
	}

	# Check for ansi2knr.
	$am_c_prototypes = 1 if /AM_C_PROTOTYPES/;

	# Check for exe extension stuff.
	if (/AC_EXEEXT/)
	{
	    $seen_exeext = 1;
	    $configure_vars{'EXEEXT'} = $filename . ':' . $.;
	}

	if (/AC_OBJEXT/)
	{
	    $seen_objext = 1;
	    $configure_vars{'OBJEXT'} = $filename . ':' . $.;
	}

	# Check for `-c -o' code.
	$seen_cc_c_o = 1 if /AM_PROG_CC_C_O/;

	# Check for NLS support.
	if (/AM_GNU_GETTEXT/)
	{
	    $seen_gettext = 1;
	    $ac_gettext_line = $.;
	}

        # Look for ALL_LINGUAS.
        if (/ALL_LINGUAS="(.*)"$/ || /ALL_LINGUAS=(.*)$/)
	{
	    $seen_linguas = 1;
	    $all_linguas = $1;
	    $all_linguas_line = $.;
	}

	# Handle configuration headers.  A config header of `[$1]'
	# means we are actually scanning AM_CONFIG_HEADER from
	# aclocal.m4.
	if (/A([CM])_CONFIG_HEADERS?\s*\((.*)\)/
	    && $2 ne '[$1]')
	{
	    &am_conf_line_error
 		($filename, $., "\`automake requires \`AM_CONFIG_HEADER', not \`AC_CONFIG_HEADER'")
 		    if $1 eq 'C';

	    $config_header_line = $.;
	    local ($one_hdr);
	    foreach $one_hdr (split (' ', $2))
	    {
		push (@config_fullnames, $one_hdr);
		if ($one_hdr =~ /^([^:]+):(.+)$/)
		{
		    push (@config_names, $1);
		    push (@config_headers, $2);
		}
		else
		{
		    push (@config_names, $one_hdr);
		    push (@config_headers, $one_hdr . '.in');
		}
	    }
	}

        # Handle AC_CANONICAL_*.  Always allow upgrading to
        # AC_CANONICAL_SYSTEM, but never downgrading.
	$seen_canonical = $AC_CANONICAL_HOST
	    if ! $seen_canonical
		&& (/AC_CANONICAL_HOST/ || /AC_CHECK_TOOL/);
        $seen_canonical = $AC_CANONICAL_SYSTEM if /AC_CANONICAL_SYSTEM/;

	$seen_path_xtra = 1 if /AC_PATH_XTRA/;

        # This macro handles several different things.
        if (/$AM_INIT_AUTOMAKE_PATTERN/o)
	{
	    $seen_make_set = 1;
	    $seen_arg_prog = 1;
	    $seen_prog_install = 1;
	    ($package_version = $1) =~ s/$AM_PACKAGE_VERSION_PATTERN/$1/o;
	    $package_version_line = $.;
	    $seen_init_automake = 1;
	}

	# Some things required by Automake.
	$seen_make_set = 1 if /AC_PROG_MAKE_SET/;
	$seen_arg_prog = 1 if /AC_ARG_PROGRAM/;

	if (/AM_PROG_LEX/)
	{
	    $configure_vars{'LEX'} = $filename . ':' . $.;
	    $seen_decl_yytext = 1;
	}
	if (/AC_DECL_YYTEXT/ && $filename =~ /configure\.(ac|in)$/)
	{
	    &am_conf_line_warning ($filename, $., "\`AC_DECL_YYTEXT' is covered by \`AM_PROG_LEX'");
	}
	if (/AC_PROG_LEX/ && $filename =~ /configure\.(ac|in)$/)
	{
 	    &am_conf_line_warning ($filename, $., "automake requires \`AM_PROG_LEX', not \`AC_PROG_LEX'");
	}

	if (/AC_PROG_(F77|YACC|RANLIB|CC|CXXCPP|CXX|LEX|AWK|CPP|LN_S)/)
	{
	    $configure_vars{$1} = $filename . ':' . $.;
	}
	if (/$AC_CHECK_PATTERN/o)
	{
	    $configure_vars{$3} = $filename . ':' . $.;
	}
	if (/$AM_MISSING_PATTERN/o
	    && $1 ne 'ACLOCAL'
	    && $1 ne 'AUTOCONF'
	    && $1 ne 'AUTOMAKE'
	    && $1 ne 'AUTOHEADER')
	{
	    $configure_vars{$1} = $filename . ':' . $.;
	}

	# Explicitly avoid ANSI2KNR -- we AC_SUBST that in protos.m4,
	# but later define it elsewhere.  This is pretty hacky.  We
	# also explicitly avoid INSTALL_SCRIPT and some other
	# variables because they are defined in header-vars.am.
	# FIXME.
	if (/$AC_SUBST_PATTERN/o
	    && $1 ne 'ANSI2KNR'
	    && $1 ne 'INSTALL_SCRIPT'
	    && $1 ne 'INSTALL_DATA')
	{
	    $configure_vars{$1} = $filename . ':' . $.;
	}

        $seen_decl_yytext = 1 if /AC_DECL_YYTEXT/;
	if (/AM_MAINTAINER_MODE/)
	{
	    $seen_maint_mode = 1;
	    $configure_cond{'MAINTAINER_MODE'} = 1;
	}

	$seen_prog_install = 1 if /AC_PROG_INSTALL/;
        $seen_lispdir = 1 if /AM_PATH_LISPDIR/;
	$seen_pythondir = 1 if /AM_PATH_PYTHON/;

        if (/A(C|M)_PROG_LIBTOOL/)
	{
	    # We're not ready for this yet.  People still use a
	    # libtool with no AC_PROG_LIBTOOL.  Once that is the
	    # dominant version we can reenable this code -- but next
	    # time by mentioning the macro in %obsolete_macros, both
	    # here and in aclocal.in.

	    # if (/AM_PROG_LIBTOOL/)
	    # {
	    # 	&am_conf_line_warning ($filename, $., "\`AM_PROG_LIBTOOL' is obsolete, use \`AC_PROG_LIBTOOL' instead");
	    # }
	    $seen_libtool = 1;
	    $libtool_line = $.;
	    $configure_vars{'LIBTOOL'} = $filename . ':' . $.;
	    $configure_vars{'RANLIB'} = $filename . ':' . $.;
	    $configure_vars{'CC'} = $filename . ':' . $.;
	    # AC_PROG_LIBTOOL runs AC_CANONICAL_HOST.  Make sure we
	    # never downgrade (if we've seen AC_CANONICAL_SYSTEM).
	    $seen_canonical = $AC_CANONICAL_HOST if ! $seen_canonical;
	}

	$seen_multilib = 1 if (/AM_ENABLE_MULTILIB/);

	if (/$AM_CONDITIONAL_PATTERN/o)
	{
	    $configure_cond{$1} = 1;
	}

	# Check for Fortran 77 intrinsic and run-time libraries.
	if (/AC_F77_LIBRARY_LDFLAGS/)
	{
	    $configure_vars{'FLIBS'} = $filename . ':' . $.;
	}
    }

    close (CONFIGURE);
}


# &scan_autoconf_files ()
# -----------------------
# Check whether we use `configure.ac' or `configure.in'.
# Scan it (and possibly `aclocal.m4') for interesting things.
# We must scan aclocal.m4 because there might be AC_SUBSTs and such there.
sub scan_autoconf_files
{
    # Reinitialize libsources here.  This isn't really necessary,
    # since we currently assume there is only one configure.ac.  But
    # that won't always be the case.
    %libsources = ();

    local ($in_ac_output, $in_ac_replace) = (0, 0);
    local (%make_list, @make_input_list);
    local ($libobj_iter);

    warn "automake: both \`configure.ac' and \`configure.in' present:"
         . " ignoring \`configure.in'\n"
        if -f 'configure.ac' && -f 'configure.in';
    $configure_ac = 'configure.in'
        if -f 'configure.in';
    $configure_ac = 'configure.ac'
        if -f 'configure.ac';
    die "automake: \`configure.ac' or \`configure.in' is required\n"
        if !$configure_ac;

    &scan_one_autoconf_file ($configure_ac);
    &scan_one_autoconf_file ('aclocal.m4')
	if -f 'aclocal.m4';

    if (defined $ENV{'amtraces'})
    {
        warn 'automake: Autoconf traces is an experimental feature';
        warn 'automake: use at your own risks';

        &scan_autoconf_traces ($configure_ac);
    }

    # Set input and output files if not specified by user.
    if (! @input_files)
    {
	@input_files = @make_input_list;
	%output_files = %make_list;
    }

    @configure_input_files = @make_input_list;

    &am_conf_error ("\`AM_INIT_AUTOMAKE' must be used")
	if ! $seen_init_automake;

    # Always require AC_PROG_MAKE_SET.  We might randomly use $(MAKE)
    # for our own reasons.
    &am_conf_error ("\`AC_PROG_MAKE_SET' must be used")
	if ! $seen_make_set;

    # Look for some files we need.  Always check for these.  This
    # check must be done for every run, even those where we are only
    # looking at a subdir Makefile.  We must set relative_dir so that
    # the file-finding machinery works.
    local ($relative_dir) = '.';
    &require_config_file ($FOREIGN, 'install-sh', 'mkinstalldirs', 'missing');
    &am_error ("\`install.sh' is an anachronism; use \`install-sh' instead")
        if -f $config_aux_path[0] . '/install.sh';

    &require_config_file ($FOREIGN, 'py-compile')
	if $seen_pythondir;

    # Preserve dist_common for later.
    %configure_dist_common = %dist_common;
}

################################################################

# Set up for Cygnus mode.
sub check_cygnus
{
    return unless $cygnus_mode;

    &set_strictness ('foreign');
    $options{'no-installinfo'} = 1;
    $options{'no-dependencies'} = 1;
    $use_dependencies = 0;

    if (! $seen_maint_mode)
    {
	&am_conf_error ("\`AM_MAINTAINER_MODE' required when --cygnus specified");
    }

    if (! $seen_exeext)
    {
	&am_conf_error ("\`AC_EXEEXT' required when --cygnus specified");
    }
}

# Do any extra checking for GNU standards.
sub check_gnu_standards
{
    if ($relative_dir eq '.')
    {
	# In top level (or only) directory.
	&require_file ($GNU, 'INSTALL', 'NEWS', 'README', 'COPYING',
		       'AUTHORS', 'ChangeLog');
    }

    if ($strictness >= $GNU)
    {
	if (defined $options{'no-installman'})
	{
	    &am_line_error ('AUTOMAKE_OPTIONS',
			    "option \`no-installman' disallowed by GNU standards");
	}

	if (defined $options{'no-installinfo'})
	{
	    &am_line_error ('AUTOMAKE_OPTIONS',
			    "option \`no-installinfo' disallowed by GNU standards");
	}
    }
}

# Do any extra checking for GNITS standards.
sub check_gnits_standards
{
    if ($relative_dir eq '.')
    {
	# In top level (or only) directory.
	&require_file ($GNITS, 'THANKS');
    }
}

################################################################
#
# Functions to handle files of each language.

# Each `lang_X_rewrite' function follows a simple formula:
# * Args are the directory, base name and extension of the file.
# * Return value is 1 if file is to be dealt with, 0 otherwise.
# Much of the actual processing is handled in handle_single_transform_list.
# These functions exist so that auxiliary information can be recorded
# for a later cleanup pass.  Note that the calls to these functions
# are computed, so don't bother searching for their precise names
# in the source.

# This is just a convenience function that can be used to determine
# when a subdir object should be used.
sub lang_sub_obj
{
    return defined $options{'subdir-objects'} ? $LANG_SUBDIR : $LANG_PROCESS;
}

# Rewrite a single C source file.
sub lang_c_rewrite
{
    local ($directory, $base, $ext) = @_;

    if (defined $options{'ansi2knr'} && $base =~ /_$/)
    {
	# FIXME: include line number in error.
	&am_error ("C source file \`$base.c' would be deleted by ansi2knr rules");
    }

    local ($r) = $LANG_PROCESS;
    if (defined $options{'subdir-objects'})
    {
	$r = $LANG_SUBDIR;
	$base = $directory . '/' . $base;

	if (! $seen_cc_c_o)
	{
	    # Only give error once.
	    $seen_cc_c_o = 1;
	    # FIXME: line number.
	    &am_error ("C objects in subdir but \`AM_PROG_CC_C_O' not in \`$configure_ac'");
	}

	&require_file ($FOREIGN, 'compile')
	    if $relative_dir eq '.';
    }

    $de_ansi_files{$base} = 1;
    return $r;
}

# Rewrite a single C++ source file.
sub lang_cxx_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single header file.
sub lang_header_rewrite
{
    # Header files are simply ignored.
    return $LANG_IGNORE;
}

# Rewrite a single yacc file.
sub lang_yacc_rewrite
{
    local ($directory, $base, $ext) = @_;

    local ($r) = &lang_c_rewrite ($directory, $base, $ext);
    local ($pfx) = '';
    if ($r == $LANG_SUBDIR)
    {
	$pfx = $directory . '/';
    }
    $yacc_sources{$pfx . $base . '.' . $ext} = 1;
    $ext =~ tr/y/c/;
    &saw_extension ('c');
    # FIXME: nodist.
    &push_dist_common ($pfx . $base . '.' . $ext);
    return $r;
}

# Rewrite a single yacc++ file.
sub lang_yaccxx_rewrite
{
    local ($directory, $base, $ext) = @_;

    local ($r) = $LANG_PROCESS;
    local ($pfx) = '';
    if (defined $options{'subdir-objects'})
    {
	$pfx = $directory . '/';
	$r = $LANG_SUBDIR;
    }
    $yacc_sources{$pfx . $base . '.' . $ext} = 1;
    $ext =~ tr/y/c/;
    &saw_extension ($ext);
    # FIXME: nodist.
    &push_dist_common ($pfx . $base . '.' . $ext);
    return $r;
}

# Rewrite a single lex file.
sub lang_lex_rewrite
{
    local ($directory, $base, $ext) = @_;

    local ($r) = &lang_c_rewrite ($directory, $base, $ext);
    local ($pfx) = '';
    if ($r == $LANG_SUBDIR)
    {
	$pfx = $directory . '/';
    }
    $lex_sources{$pfx . $base . '.' . $ext} = 1;
    $ext =~ tr/l/c/;
    &saw_extension ('c');
    # FIXME: nodist.
    &push_dist_common ($pfx . $base . '.' . $ext);
    return $r;
}

# Rewrite a single lex++ file.
sub lang_lexxx_rewrite
{
    local ($directory, $base, $ext) = @_;

    local ($r) = $LANG_PROCESS;
    local ($pfx) = '';
    if (defined $options{'subdir-objects'})
    {
	$pfx = $directory . '/';
	$r = $LANG_SUBDIR;
    }
    $lex_sources{$pfx . $base . '.' . $ext} = 1;
    $ext =~ tr/l/c/;
    &saw_extension ($ext);
    # FIXME: nodist.
    &push_dist_common ($pfx . $base . '.' . $ext);
    return $r;
}

# Rewrite a single assembly file.
sub lang_asm_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single Fortran 77 file.
sub lang_f77_rewrite
{
    return $LANG_PROCESS;
}

# Rewrite a single preprocessed Fortran 77 file.
sub lang_ppf77_rewrite
{
    return $LANG_PROCESS;
}

# Rewrite a single ratfor file.
sub lang_ratfor_rewrite
{
    return $LANG_PROCESS;
}

# Rewrite a single Objective C file.
sub lang_objc_rewrite
{
    return &lang_sub_obj;
}

# Rewrite a single Java file.
sub lang_java_rewrite
{
    return $LANG_SUBDIR;
}

# The lang_X_finish functions are called after all source file
# processing is done.  Each should handle defining rules for the
# language, etc.  A finish function is only called if a source file of
# the appropriate type has been seen.

sub lang_c_finish
{
    # Push all libobjs files onto de_ansi_files.  We actually only
    # push files which exist in the current directory, and which are
    # genuine source files.
    local ($file);
    foreach $file (keys %libsources)
    {
	if ($file =~ /^(.*)\.[cly]$/ && -f "$relative_dir/$file")
	{
	    $de_ansi_files{$1} = 1;
	}
    }

    if (defined $options{'ansi2knr'} && keys %de_ansi_files)
    {
 	# Make all _.c files depend on their corresponding .c files.
 	local ($base, @objects);
 	foreach $base (sort keys %de_ansi_files)
 	{
	    # Each _.c file must depend on ansi2knr; otherwise it
	    # might be used in a parallel build before it is built.
	    # We need to support files in the srcdir and in the build
	    # dir (because these files might be auto-generated.  But
	    # we can't use $< -- some makes only define $< during a
	    # suffix rule.
 	    $output_rules .= ($base . "_.c: $base.c \$(ANSI2KNR)\n\t"
			      . '$(CPP) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) '
			      . '`if test -f $(srcdir)/' . $base . '.c'
			      . '; then echo $(srcdir)/' . $base . '.c'
			      . '; else echo ' . $base . '.c; fi` '
			      . "| sed 's/^# \\([0-9]\\)/#line \\1/' "
			      . '| $(ANSI2KNR) > ' . $base . "_.c\n");
 	    push (@objects, $base . '_'
		  . ($seen_objext ? '.$(OBJEXT)' : '.o'));
 	    push (@objects, $base . '_.lo') if $seen_libtool;
 	}

 	# Make all _.o (and _.lo) files depend on ansi2knr.
 	# Use a sneaky little hack to make it print nicely.
 	&pretty_print_rule ('', '', @objects, ':', '$(ANSI2KNR)');
    }

    if (! defined $configure_vars{'CC'})
    {
	# FIXME: line number.
	&am_error ("C source seen but \`CC' not defined in \`$configure_ac'");
    }
}

sub lang_cxx_finish
{
    local ($ltcompile, $ltlink) = &libtool_compiler;

    &define_variable ('CXXLD', '$(CXX)');
    &define_variable ('CXXLINK', $ltlink . '$(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@');

    if (! defined $configure_vars{'CXX'})
    {
	&am_error ("C++ source seen but \`CXX' not defined in \`$configure_ac'");
    }
}

sub lang_header_finish
{
    # Nothing to do.
}

# This is a helper for both lex and yacc.
sub yacc_lex_finish_helper
{
    return if defined $language_scratch{'lex-yacc-done'};
    $language_scratch{'lex-yacc-done'} = 1;

    # If there is more than one distinct yacc (resp lex) source file
    # in a given directory, then the `ylwrap' program is required to
    # allow parallel builds to work correctly.  FIXME: for now, no
    # line number.
    &require_config_file ($FOREIGN, 'ylwrap');
    if ($config_aux_dir ne '.' && $config_aux_dir ne '')
    {
	&define_variable ('YLWRAP', $config_aux_dir . "/ylwrap");
    }
    else
    {
	&define_variable ('YLWRAP', '$(srcdir)/ylwrap');
    }
}

sub lang_yacc_finish
{
    return if defined $language_scratch{'yacc-done'};
    $language_scratch{'yacc-done'} = 1;

    local ($file, $base, $hname, $cname);
    local (%seen_suffix) = ();
    local (@yacc_files) = sort keys %yacc_sources;
    local ($yacc_count) = scalar (@yacc_files);
    foreach $file (@yacc_files)
    {
	$file =~ /(\..*)$/;
	&output_yacc_build_rule ($1, $yacc_count > 1)
	    if ! defined $seen_suffix{$1};
	$seen_suffix{$1} = 1;

	$file =~ /^(.*)\.(y|yy|y\+\+|yxx|ypp)$/;
	$base = $1;
	$hname = 'h';		# Always use `.h' for header file.
	($cname = $2) =~ tr/y/c/;

	if ((&variable_defined ('AM_YFLAGS')
	     && &variable_value ('AM_YFLAGS') =~ /(^|\s)-d(\s|$)/)
	    || (&variable_defined ('YFLAGS')
		&& &variable_value ('YFLAGS') =~ /(^|\s)-d(\s|$)/)) {
	    # Now generate rule to make the header file.  This should only
	    # be generated if `yacc -d' specified.
	    $output_rules .= "${base}.${hname}: ${base}.${cname}\n";

	    # If the files are built in the build directory, then we want
	    # to remove them with `make clean'.  If they are in srcdir
	    # they shouldn't be touched.  However, we can't determine this
	    # statically, and the GNU rules say that yacc/lex output files
	    # should be removed by maintainer-clean.  So that's what we
	    # do.
	    push (@maintainer_clean_files, "${base}.${hname}");

	    &push_dist_common ("${base}.${hname}");
	}
	push (@maintainer_clean_files, "${base}.${cname}");
    }
    $output_rules .= "\n";

    if (! defined $configure_vars{'YACC'})
    {
	&am_error ("yacc source seen but \`YACC' not defined in \`$configure_ac'");
    }
    if (&variable_defined ('YACCFLAGS'))
    {
	&am_line_error ('YACCFLAGS',
			"\`YACCFLAGS' obsolete; use \`YFLAGS' instead");
    }

    if ($yacc_count > 1)
    {
	&yacc_lex_finish_helper;
    }
}

sub lang_yaccxx_finish
{
    &lang_yacc_finish;
}

sub lang_lex_finish
{
    return if defined $language_scratch{'lex-done'};
    $language_scratch{'lex-done'} = 1;

    local (%seen_suffix) = ();
    local ($file, $cname);
    local ($lex_count) = scalar (keys %lex_sources);
    foreach $file (sort keys %lex_sources)
    {
	$file =~ /(\..*)$/;
	&output_lex_build_rule ($1, $lex_count > 1)
	    if (! defined $seen_suffix{$1});
	$seen_suffix{$1} = 1;

	# If the files are built in the build directory, then we want
	# to remove them with `make clean'.  If they are in srcdir
	# they shouldn't be touched.  However, we can't determine this
	# statically, and the GNU rules say that yacc/lex output files
	# should be removed by maintainer-clean.  So that's what we
	# do.
	$file =~ /^(.*)\.(l|ll|l\+\+|lxx|lpp)$/;
	($cname = $2) =~ tr/l/c/;
	push (@maintainer_clean_files, "${1}.${cname}");
    }

    if (! defined $configure_vars{'LEX'})
    {
	&am_error ("lex source seen but \`LEX' not defined in \`$configure_ac'");
    }
    if (! $seen_decl_yytext)
    {
	&am_error ("lex source seen but \`AC_DECL_YYTEXT' not in \`$configure_ac'");
    }

    if ($lex_count > 1)
    {
	&yacc_lex_finish_helper;
    }
}

sub lang_lexxx_finish
{
    &lang_lex_finish;
}

sub lang_asm_finish
{
    # We need the C code for assembly.
    &lang_c_finish;
}

sub lang_f77_finish
{
    # FIXME: this function can be called more than once.  We should
    # arrange for it to only do anything the first time through.

    local ($ltcompile, $ltlink) = &libtool_compiler;

    &define_variable ('F77LD', '$(F77)');
    &define_variable ('F77LINK', $ltlink . '$(F77LD) $(AM_FFLAGS) $(FFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@');

    if (! defined $configure_vars{'F77'})
    {
	&am_error ("Fortran 77 source seen but \`F77' not defined in \`$configure_ac'");
    }
}

# Preprocessed Fortran 77
#
# The current support for preprocessing Fortran 77 just involves passing
# `$(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS)' as additional flags
# to the Fortran 77 compiler, since this is how GNU Make does it; see
# the `GNU Make Manual, Edition 0.51 for `make' Version 3.76 Beta'
# (specifically, from info file `(make)Catalogue of Rules').
#
# A better approach would be to write an Autoconf test
# (i.e. AC_PROG_FPP) for a Fortran 77 preprocessor, because not all
# Fortran 77 compilers know how to do preprocessing.  The Autoconf macro
# AC_PROG_FPP should test the Fortran 77 compiler first for
# preprocessing capabilities, and then fall back on cpp (if cpp were
# available).
sub lang_ppf77_finish
{
    &lang_f77_finish;

    # We also handle the case of preprocessing `.F' files into `.f'
    # files.
    $output_rules .= (".F.f:\n"
		      . "\t\$(F77COMPILE) -F \$<\n");
}

sub lang_ratfor_finish
{
    &lang_f77_finish;

    # We also handle the case of preprocessing `.r' files into `.f'
    # files.
    $output_rules .= (".r.f:\n"
		      . "\t\$(RCOMPILE) -F \$<\n");
}

sub lang_objc_finish
{
    local ($ltcompile, $ltlink) = &libtool_compiler;

    &define_variable ('OBJCLD', '$(OBJC)');
    &define_variable ('OBJCLINK', $ltlink . '$(OBJCLD) $(AM_OBJCFLAGS) $(OBJCFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@');

    if (! defined $configure_vars{'OBJC'})
    {
	&am_error ("Objective C source seen but \`OBJC' not defined in \`$configure_ac'");
    }
}

sub lang_java_finish
{
    local ($ltcompile, $ltlink) = &libtool_compiler;

    &define_variable ('GCJLD', '$(GCJ)');
    &define_variable ('GCJLINK', $ltlink . '$(GCJLD) $(AM_GCJFLAGS) $(GCJFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@');

    if (! defined $configure_vars{'GCJ'})
    {
	&am_error ("Java source seen but \`GCJ' not defined in \`$configure_ac'");
    }
}

# A helper which computes a sorted list of all extensions for LANG.
sub lang_extensions
{
    local ($lang) = @_;
    local ($key, @r);
    foreach $key (sort keys %extension_seen)
    {
	push (@r, '.' . $key) if $extension_map{$key} eq $lang;
    }
    return @r;
}

# A helper which decides whether libtool is needed.  Returns prefix
# for compiler and linker.
sub libtool_compiler
{
    local ($ltcompile, $ltlink) = ('', '');
    if ($seen_libtool)
    {
	&define_configure_variable ("LIBTOOL");
	$ltcompile = '$(LIBTOOL) --mode=compile ';
	$ltlink = '$(LIBTOOL) --mode=link ';
    }
    return ($ltcompile, $ltlink);
}

# Given a hash table of linker names, pick the name that has the most
# precedence.  This is lame, but something has to have global
# knowledge in order to eliminate the conflict.  Add more linkers as
# required.
sub resolve_linker
{
    local (%linkers) = @_;

    return 'GCJLINK'
	if defined $linkers{'GCJLINK'};
    return 'CXXLINK'
	if defined $linkers{'CXXLINK'};
    return 'F77LINK'
	if defined $linkers{'F77LINK'};
    return 'OBJCLINK'
        if defined $linkers{'OBJCLINK'};
    return 'LINK';
}

# Called to indicate that an extension was used.
sub saw_extension
{
    local ($ext) = @_;
    $extension_seen{$ext} = 1;
}

# Called to ask whether source files have been seen . If HEADERS is 1,
# headers can be included.
sub saw_sources_p
{
    local ($headers) = @_;

    if ($headers)
    {
	$headers = 0;
    }
    else
    {
	local (@exts) = &lang_extensions ('header');
	$headers = @exts;
    }

    return scalar keys %extension_seen > $headers;
}

# Register a single language.  LANGUAGE is the name of the language.
# Each OPTION is either of the form NAME=VALUE, or is a file extension
# (sans `.').
sub register_language
{
    local ($language, @options) = @_;

    # Set the defaults.
    $language_map{$language . '-ansi-p'} = 0;
    $language_map{$language . '-linker'} = '';
    $language_map{$language . '-autodep'} = 'no';
    $language_map{$language . '-derived-autodep'} = 'no';

    local ($iter);
    foreach $iter (@options)
    {
	if ($iter =~ /^(.*)=(.*)$/)
	{
	    $language_map{$language . '-' . $1} = $2;
	}
	elsif (defined $extension_map{$iter})
	{
	    &prog_error ("duplicate extension $iter");
	}
	else
	{
	    $extension_map{$iter} = $language;
	}
    }
}

# This function is used to find a path from a user-specified suffix to
# `o' or to some other suffix we recognize internally, eg `cc'.
sub derive_suffix
{
    local ($source_ext) = @_;

    # FIXME: hard-coding `o' is a mistake.  Doing something
    # intelligent is harder.
    while ($extension_map{$source_ext} eq ''
	   && $source_ext ne 'o'
	   && defined $suffix_rules{$source_ext})
    {
	$source_ext = $suffix_rules{$source_ext};
    }

    return $source_ext;
}


################################################################

# Pretty-print something.  HEAD is what should be printed at the
# beginning of the first line, FILL is what should be printed at the
# beginning of every subsequent line.
sub pretty_print_internal
{
    local ($head, $fill, @values) = @_;

    local ($column) = length ($head);
    local ($result) = $head;

    # Fill length is number of characters.  However, each Tab
    # character counts for eight.  So we count the number of Tabs and
    # multiply by 7.
    local ($fill_length) = length ($fill);
    $fill_length += 7 * ($fill =~ tr/\t/\t/d);

    local ($bol) = ($head eq '');
    foreach (@values)
    {
	# "71" because we also print a space.
	if ($column + length ($_) > 71)
	{
	    $result .= " \\\n" . $fill;
	    $column = $fill_length;
	    $bol = 1;
	}

	$result .= ' ' unless ($bol);
	$result .= $_;
	$column += length ($_) + 1;
	$bol = 0;
    }

    $result .= "\n";
    return $result;
}

# Pretty-print something and append to output_vars.
sub pretty_print
{
    $output_vars .= &pretty_print_internal (@_);
}

# Pretty-print something and append to output_rules.
sub pretty_print_rule
{
    $output_rules .= &pretty_print_internal (@_);
}


################################################################

# See if a target exists.
sub target_defined
{
    local ($target) = @_;
    return defined $targets{$target};
}

# See if two conditionals are the same.
sub conditional_same
{
    local ($cond1, $cond2) = @_;

    return (&conditional_true_when ($cond1, $cond2)
	    && &conditional_true_when ($cond2, $cond1));
}

# See if a conditional is true.  Both arguments are conditional
# strings.  This returns true if the first conditional is true when
# the second conditional is true.
sub conditional_true_when
{
    local ($cond, $when) = @_;

    # Check the easy case first.
    if ($cond eq $when)
    {
	return 1;
    }

    # Check each component of $cond, which looks @COND1@@COND2@.
    foreach $comp (split ('@', $cond))
    {
	# The way we split will give null strings between each
	# condition.
	next if ! $comp;

	if (index ($when, '@' . $comp . '@') == -1)
	{
	    return 0;
	}
    }

    return 1;
}

# Check for an ambiguous conditional.  This is called when a variable
# or target is being defined conditionally.  If we already know about
# a definition that is true under the same conditions, then we have an
# ambiguity.
sub check_ambiguous_conditional
{
    local ($var_name, $cond) = @_;
    local (@cond_vals) = split (' ', $conditional{$var_name});
    while (@cond_vals)
    {
	local ($vcond) = shift (@cond_vals);
	shift (@cond_vals);
	if (&conditional_true_when ($vcond, $cond)
	    || &conditional_true_when ($cond, $vcond))
	{
	    &am_line_error ($var_name,
			    "$var_name multiply defined in condition");
	}
    }
}

# See if a variable exists.  The first argument is the variable name,
# and the optional second argument is the condition which we should
# check.  If no condition is given, we currently return true if the
# variable is defined under any condition.
sub variable_defined
{
    local ($var, $cond) = @_;
    if (defined $targets{$var})
    {
	&am_line_error ($var, "\`$var' is target; expected variable");
	return 0;
    }
    elsif (defined $contents{$var})
    {
	if ($cond && $conditional{$var})
	{
	    # We have been asked to check for a particular condition,
	    # and the variable is defined conditionally.  We need to
	    # look through the conditions under which the variable is
	    # defined, and see if any of them match the conditional we
	    # have been asked to check.
	    local (@cond_vars) = split (' ', $conditional{$var});
	    while (@cond_vars)
	    {
		if (&conditional_same ($cond, shift (@cond_vars)))
		{
		    # Even a conditional examination is good enough
		    # for us.  FIXME: really should maintain examined
		    # status on a per-condition basis.
		    $content_seen{$var} = 1;
		    return 1;
		}
		shift (@cond_vars);
	    }

	    # The variable is not defined for the given condition.
	    return 0;
	}

	$content_seen{$var} = 1;
	return 1;
    }
    return 0;
}

# Mark a variable as examined.
sub examine_variable
{
    local ($var) = @_;
    &variable_defined ($var);
}

# Quote a value in order to put it in $conditional.  We need to quote
# spaces, and we need to handle null strings, so that we can later
# retrieve values by splitting on space.
sub quote_cond_val
{
    local ($val) = @_;
    $val =~ tr/ \t\n/\001\003\004/;
    $val = "\002" if $val eq '';
    return $val;
}

# Unquote a value in $conditional.
sub unquote_cond_val
{
    local ($val) = @_;
    $val =~ tr/\001\003\004/ \t\n/;
    $val =~ s/\002//g;
    return $val;
}

# Return the set of conditions for which a variable is defined.

# If the variable is not defined conditionally, and is not defined in
# terms of any variables which are defined conditionally, then this
# returns the empty list.

# If the variable is defined conditionally, but is not defined in
# terms of any variables which are defined conditionally, then this
# returns the list of conditions for which the variable is defined.

# If the variable is defined in terms of any variables which are
# defined conditionally, then this returns a full set of permutations
# of the subvariable conditions.  For example, if the variable is
# defined in terms of a variable which is defined for @COND_TRUE@,
# then this returns both @COND_TRUE@ and @COND_FALSE@.  This is
# because we will need to define the variable under both conditions.

sub variable_conditions
{
    local ($var) = @_;
    local (%uniqify);
    local (@uniq_list);
    local ($cond);

    %vars_scanned = ();
    foreach $cond (&variable_conditions_sub ($var, '', ()))
    {
	$uniqify{$cond} = 1;
    }

    @uniq_list = sort keys %uniqify;
    # Note we cannot just do `return sort keys %uniqify', because this
    # function is sometimes used in a scalar context.
    return @uniq_list;
}

# A subroutine of variable_conditions.  We only return conditions
# which are true for all the conditions in @PARENT_CONDS.
sub variable_conditions_sub
{
    local ($var, $parent, @parent_conds) = @_;
    local (@new_conds) = ();

    if (defined $vars_scanned{$var})
    {
	&am_line_error ($parent, "variable \`$var' recursively defined");
	return ();
    }
    $vars_scanned{$var} = 1;

    if (! $conditional{$var})
    {
	foreach (split (' ', $contents{$var}))
	{
	    # If a comment seen, just leave.
	    last if /^#/;

	    # Handle variable substitutions.
	    if (/^\$\{(.*)\}$/ || /^\$\((.*)\)$/)
	    {
		push (@new_conds,
		      &variable_conditions_sub ($1, $var, @parent_conds));
	    }
	}

	# Now we want to return all permutations of the subvariable
	# conditions.
	local (%allconds, $item);
	foreach $item (@new_conds)
	{
	    foreach (split ('@', $item))
	    {
		next if ! $_;
		s/_(TRUE|FALSE)$//;
		$allconds{$_ . '_TRUE'} = 1;
	    }
	}

	# Unset our entry in vars_scanned.  We only care about recursive
	# definitions.
	delete $vars_scanned{$var};

	return &variable_conditions_permutations (sort keys %allconds);
    }

    local (@this_conds) = ();
    local (@condvals) = split (' ', $conditional{$var});
    while (@condvals)
    {
	local ($cond) = shift (@condvals);
	local ($val) = &unquote_cond_val (shift (@condvals));

	if (@parent_conds)
	{
	    local ($ok) = 1;
	    local ($parent_cond);
	    foreach $parent_cond (@parent_conds)
	    {
		if (! &conditional_true_when ($parent_cond, $cond))
		{
		    $ok = 0;
		    last;
		}
	    }

	    next if ! $ok;
	}

	push (@this_conds, $cond);

	push (@parent_conds, $cond);
	local (@subvar_conds) = ();
	foreach (split (' ', $val))
	{
	    # If a comment seen, just leave.
	    last if /^#/;

	    # Handle variable substitutions.
	    if (/^\$\{(.*)\}$/ || /^\$\((.*)\)$/)
	    {
		push (@subvar_conds,
		      &variable_conditions_sub ($1, $var, @parent_conds));
	    }
	}
	pop (@parent_conds);

	# If there are no conditional subvariables, then we want to
	# return this condition.  Otherwise, we want to return the
	# permutations of the subvariables.
	if (! @subvar_conds)
	{
	    push (@new_conds, $cond);
	}
	else
	{
	    push (@new_conds, &variable_conditions_reduce (@subvar_conds));
	}
    }

    # Unset our entry in vars_scanned.  We only care about recursive
    # definitions.
    delete $vars_scanned{$var};

    return @new_conds
	if ! $parent;

    # If we are being called on behalf of another variable, we need to
    # return all possible permutations of the conditions.  We have
    # already handled everything in @this_conds along with their
    # subvariables.  We now need to add any permutations that are not
    # in @this_conds.
    local ($this_cond);
    foreach $this_cond (@this_conds)
    {
	local (@perms) =
	    &variable_conditions_permutations (split('@', $this_cond));
	local ($perm);
	foreach $perm (@perms)
	{
	    local ($scan);
	    local ($ok) = 1;
	    foreach $scan (@this_conds)
	    {
		if (&conditional_true_when ($perm, $scan)
		    || &conditional_true_when ($scan, $perm))
		{
		    $ok = 0;
		    last;
		}
	    }
	    next if ! $ok;

	    if (@parent_conds)
	    {
		local ($ok) = 1;
		local ($parent_cond);
		foreach $parent_cond (@parent_conds)
		{
		    if (! &conditional_true_when ($parent_cond, $perm))
		    {
			$ok = 0;
			last;
		    }
		}

		next if ! $ok;
	    }

	    # This permutation was not already handled, and is valid
	    # for the parents.
	    push (@new_conds, $perm);
	}
    }

    return @new_conds;
}

# Subroutine for variable_conditions_sort
sub variable_conditions_cmp
{
    local ($as) = $a;
    $as =~ s/[^@]//g;
    local ($bs) = $b;
    $bs =~ s/[^@]//g;
    return (length ($as) <=> length ($bs)
	    || $a cmp $b);
}

# Sort a list of conditionals so that only the exclusive ones are
# retained.  For example, if both @COND1_TRUE@@COND2_TRUE@ and
# @COND1_TRUE@ are in the list, discard the latter.
sub variable_conditions_reduce
{
    local (@conds) = @_;
    local (@ret) = ();
    local ($cond);
    foreach $cond (sort variable_conditions_cmp @conds)
    {
	local ($ok) = 1;
	local ($scan);
	foreach $scan (@ret)
	{
	    if (&conditional_true_when ($cond, $scan))
	    {
		$ok = 0;
		last;
	    }
	}
	next if ! $ok;
	push (@ret, $cond);
    }

    return @ret;
}

# Return a list of permutations of a conditional string.
sub variable_conditions_permutations
{
    local (@comps) = @_;
    return ()
	if ! @comps;
    local ($comp) = shift (@comps);
    return &variable_conditions_permutations (@comps)
	if $comp eq '';
    local ($neg) = $comp;
    $neg =~ s/TRUE$/TRUEO/;
    $neg =~ s/FALSE$/TRUE/;
    $neg =~ s/TRUEO$/FALSE/;
    local (@ret);
    local ($sub);
    foreach $sub (&variable_conditions_permutations (@comps))
    {
	push (@ret, '@' . $comp . '@' . $sub);
	push (@ret, '@' . $neg . '@' . $sub);
    }
    if (! @ret)
    {
	push (@ret, '@' . $comp . '@');
	push (@ret, '@' . $neg . '@');
    }
    return @ret;
}

# Warn if a variable is conditionally defined.  This is called if we
# are using the value of a variable.
sub variable_conditionally_defined
{
    local ($var, $parent) = @_;
    if ($conditional{$var})
    {
	if ($parent)
	{
	    &am_line_error ($parent,
			    "warning: automake does not support conditional definition of $var in $parent");
	}
	else
	{
	    &am_line_error ($parent,
			    "warning: automake does not support $var being defined conditionally")
	}
    }
}

# Get the value of a variable.  This just returns $contents, but warns
# if the variable is conditionally defined.
sub variable_value
{
    local ($var) = @_;
    &variable_conditionally_defined ($var);
    return $contents{$var};
}

# Convert a variable value to a list, split as whitespace.  This will
# recursively follow $(...) and ${...} inclusions.  It preserves @...@
# substitutions.  If COND is 'all', then all values under all
# conditions should be returned; if COND is a particular condition
# (all conditions are surrounded by @...@) then only the value for
# that condition should be returned; otherwise, warn if VAR is
# conditionally defined.  SCANNED is a global hash listing whose keys
# are all the variables already scanned; it is an error to rescan a
# variable.
sub value_to_list
{
    local ($var, $val, $cond) = @_;
    local (@result);

    # Strip backslashes
    $val =~ s/\\(\n|$)/ /g;

    foreach (split (' ', $val))
    {
	# If a comment seen, just leave.
	last if /^#/;

	# Handle variable substitutions.
	if (/^\$\{([^}]*)\}$/ || /^\$\(([^)]*)\)$/)
	{
	    local ($varname) = $1;

	    # If the user uses a losing variable name, just ignore it.
	    # This isn't ideal, but people have requested it.
	    next if ($varname =~ /\@.*\@/);

	    local ($from, $to);
	    local (@temp_list);
	    if ($varname =~ /^([^:]*):([^=]*)=(.*)$/)
	    {
		$varname = $1;
		$to = $3;
		($from = $2) =~ s/(\W)/\\$1/g;
	    }

	    # Find the value.
	    @temp_list = &variable_value_as_list_worker ($1, $cond, $var);

	    # Now rewrite the value if appropriate.
	    if ($from)
	    {
		grep (s/$from$/$to/, @temp_list);
	    }

	    push (@result, @temp_list);
	}
	else
	{
	    push (@result, $_);
	}
    }

    return @result;
}

# Return contents of variable as list, split as whitespace.  This will
# recursively follow $(...) and ${...} inclusions.  It preserves @...@
# substitutions.  If COND is 'all', then all values under all
# conditions should be returned; if COND is a particular condition
# (all conditions are surrounded by @...@) then only the value for
# that condition should be returned; otherwise, warn if VAR is
# conditionally defined.  If PARENT is specified, it is the name of
# the including variable; this is only used for error reports.
sub variable_value_as_list_worker
{
    local ($var, $cond, $parent) = @_;
    local (@result);

    if (defined $targets{$var})
    {
	&am_line_error ($var, "\`$var' is target; expected variable");
    }
    elsif (! defined $contents{$var} && ! defined $am_var_defs{$var})
    {
	&am_line_error ($parent, "variable \`$var' not defined");
    }
    elsif (defined $vars_scanned{$var})
    {
	# `vars_scanned' is a global we use to keep track of which
	# variables we've already examined.
	&am_line_error ($parent, "variable \`$var' recursively defined");
    }
    elsif ($cond eq 'all' && $conditional{$var})
    {
	$vars_scanned{$var} = 1;
	local (@condvals) = split (' ', $conditional{$var});
	while (@condvals)
	{
	    shift (@condvals);
	    local ($val) = &unquote_cond_val (shift (@condvals));
	    push (@result, &value_to_list ($var, $val, $cond));
	}
    }
    elsif ($cond && $conditional{$var})
    {
	$vars_scanned{$var} = 1;
	local (@condvals) = split (' ', $conditional{$var});
	local ($onceflag);
	while (@condvals)
	{
	    local ($vcond) = shift (@condvals);
	    local ($val) = &unquote_cond_val (shift (@condvals));
	    if (&conditional_true_when ($vcond, $cond))
	    {
		# Warn if we have an ambiguity.  It's hard to know how
		# to handle this case correctly.
		&variable_conditionally_defined ($var, $parent)
		    if $onceflag;
		$onceflag = 1;
		push (@result, &value_to_list ($var, $val, $cond));
	    }
	}
    }
    elsif (defined $am_var_defs{$var})
    {
	$vars_scanned{$var} = 1;
	&variable_conditionally_defined ($var, $parent);
	$content_seen{$var} = 1;
	push (@result, &value_to_list ($var, $am_var_defs{$var}, $cond));
    }
    else
    {
	$vars_scanned{$var} = 1;
	&variable_conditionally_defined ($var, $parent);
	$content_seen{$var} = 1;
	push (@result, &value_to_list ($var, $contents{$var}, $cond));
    }

    # Unset our entry in vars_scanned.  We only care about recursive
    # definitions.
    delete $vars_scanned{$var};

    return @result;
}

# This is just a wrapper for variable_value_as_list_worker that
# initializes the global hash `vars_scanned'.  This hash is used to
# avoid infinite recursion.
sub variable_value_as_list
{
    local ($var, $cond, $parent) = @_;
    %vars_scanned = ();
    return &variable_value_as_list_worker ($var, $cond, $parent);
}


# define_variable ($VAR, $VALUE)
# ------------------------------
# Define a new variable VAR to VALUE, but only if not already defined.
sub define_variable
{
    local ($var, $value) = @_;

    if (! defined $contents{$var})
    {
	$output_vars .= $var . ' = ' . $value . "\n";
	$contents{$var} = $value;
	$content_seen{$var} = 1;
    }
    elsif ($var_was_plus_eq{$var})
    {
	&am_line_error ($var, "internally generated variable \`$var' was set with \`+='");
    }
}

# Like define_variable, but the value is a list, and the variable may
# be defined conditionally.  The second argument is the conditional
# under which the value should be defined; this should be the empty
# string to define the variable unconditionally.  The third argument
# is a list holding the values to use for the variable.  The value is
# pretty printed in the output file.
sub define_pretty_variable
{
    local ($var, $cond, @value) = @_;
    if (! defined $contents{$var}
	|| ($cond && ! &variable_defined ($var, $cond)))
    {
	$contents{$var} = join (' ', @value);
	if ($cond)
	{
	    if ($conditional{$var})
	    {
		$conditional{$var} .= ' ';
	    }
	    else
	    {
		$conditional{$var} = '';
	    }
	    $conditional{$var} .= ($cond
				   . ' '
				   . &quote_cond_val ($contents{$var}));
	}
	&pretty_print ($cond . $var . ' = ', $cond, @value);
	$content_seen{$var} = 1;
    }
}

# Like define_variable, but define a variable to be the configure
# substitution by the same name.
sub define_configure_variable
{
    local ($var) = @_;
    local ($value) = '@' . $var . '@';
    &define_variable ($var, $value);
}

# Define a compiler variable.  We also handle defining the `LT'
# version of the command when using libtool.
sub define_compiler_variable
{
    local ($var, $ltcompile, $value) = @_;
    local ($name) = $var;
    &define_variable ($name, $value);
    &define_variable ('LT' . $name, $ltcompile . $value)
	if $seen_libtool;
}

# Define a variable that represents a program to run.  If in Cygnus
# mode, the program is searched for in the build (or source) tree.
# Otherwise no searching is done at all.  Arguments are:
# * VAR      Name of variable to define
# * WHATDIR  Either `src' or `build', depending on where program should
#            be found.  (runtest is in srcdir!)
# * SUBDIR   Subdir of top-level dir
# * PROGRAM  Name of program
# * OVERRIDE If specified, the name of the program to use when not in
#            Cygnus mode.  Defaults to PROGRAM.
sub define_program_variable
{
    local ($var, $whatdir, $subdir, $program, $override) = @_;

    if (! $override)
    {
	$override = $program;
    }

    if ($cygnus_mode)
    {
	local ($full) = ('$(top_' . $whatdir . 'dir)/../'
			 . $subdir . '/' . $program);
	&define_variable ($var, ('`if test -f ' . $full
				 . '; then echo ' . $full . '; else echo '
				 . $program . '; fi`'));
    }
    else
    {
	&define_variable ($var, $override);
    }
}


################################################################

# Read Makefile.am and set up %contents.  Simultaneously copy lines
# from Makefile.am into $output_trailer or $output_vars as
# appropriate.  NOTE we put rules in the trailer section.  We want
# user rules to come after our generated stuff.
sub read_am_file
{
    local ($amfile) = @_;
    local (*AM_FILE);

    open (AM_FILE, $amfile) || die "automake: couldn't open \`$amfile': $!\n";
    print "automake: reading $amfile\n" if $verbose;

    local ($saw_bk) = 0;
    local ($was_rule) = 0;
    local ($spacing) = '';
    local ($comment) = '';
    local ($last_var_name) = '';
    local ($blank) = 0;

    # We save the conditional stack on entry, and then check to make
    # sure it is the same on exit.  This lets us conditonally include
    # other files.
    local (@saved_cond_stack) = @conditional_stack;

    while (<AM_FILE>)
    {
	if (/$IGNORE_PATTERN/o)
	{
	    # Merely delete comments beginning with two hashes.
	}
	elsif (/$WHITE_PATTERN/o)
	{
	    # Stick a single white line before the incoming macro or rule.
	    $spacing = "\n";
	    $blank = 1;
	}
	elsif (/$COMMENT_PATTERN/o)
	{
	    # Stick comments before the incoming macro or rule.  Make
	    # sure a blank line preceeds first block of comments.
	    $spacing = "\n" unless $blank;
	    $blank = 1;
	    $comment .= $spacing . $_;
	    $spacing = '';
	}
	else
	{
	    last;
	}
    }

    $output_vars .= $comment . "\n";
    $comment = '';
    $spacing = "\n";

    local ($is_ok_macro);
    while ($_)
    {
	$_ .= "\n"
	    unless substr ($_, -1, 1) eq "\n";

	# Don't look at MAINTAINER_MODE_TRUE here.  That shouldn't be
	# used by users.  @MAINT@ is an anachronism now.
	$_ =~ s/\@MAINT\@//g
	    unless $seen_maint_mode;

	if (/$IGNORE_PATTERN/o)
	{
	    # Merely delete comments beginning with two hashes.
	}
	elsif (/$WHITE_PATTERN/o)
	{
	    # Stick a single white line before the incoming macro or rule.
	    $spacing = "\n";
	    &am_line_error ($., "blank line following trailing backslash")
		if $saw_bk;
	}
	elsif (/$COMMENT_PATTERN/o)
	{
	    # Stick comments before the incoming macro or rule.
	    $comment .= $spacing . $_;
	    $spacing = '';
	    &am_line_error ($., "comment following trailing backslash")
		if $saw_bk;
	}
	elsif ($saw_bk)
	{
	    if ($was_rule)
	    {
		$output_trailer .= join ('', @conditional_stack) . $_;
		$saw_bk = /\\$/;
	    }
	    else
	    {
		$saw_bk = /\\$/;
		$contents{$last_var_name} .= ' '
		    unless $contents{$last_var_name} =~ /\s$/;
		$contents{$last_var_name} .= $_;
		if (@conditional_stack)
		{
		    $conditional{$last_var_name} .= &quote_cond_val ($_);
		}
	    }
	}
	elsif (/$IF_PATTERN/o)
	{
	    &am_line_error ($., "$1 does not appear in AM_CONDITIONAL")
		if (! $configure_cond{$1});
	    push (@conditional_stack, "\@" . $1 . "_TRUE\@");
	}
	elsif (/$ELSE_PATTERN/o)
	{
	    if (! @conditional_stack)
	    {
		&am_line_error ($., "else without if");
	    }
	    elsif ($conditional_stack[$#conditional_stack] =~ /_FALSE\@$/)
	    {
		&am_line_error ($., "else after else");
	    }
	    else
	    {
		$conditional_stack[$#conditional_stack]
		    =~ s/_TRUE\@$/_FALSE\@/;
	    }
	}
	elsif (/$ENDIF_PATTERN/o)
	{
	    if (! @conditional_stack)
	    {
		&am_line_error ($., "endif without if");
	    }
	    else
	    {
		pop @conditional_stack;
	    }
	}
	elsif (/$RULE_PATTERN/o)
	{
	    # Found a rule.
	    $was_rule = 1;
	    if (defined $contents{$1}
		&& (@conditional_stack
		    ? ! defined $conditional{$1}
		    : defined $conditional{$1}))
	    {
		&am_line_error ($1,
				"$1 defined both conditionally and unconditionally");
	    }
	    # Value here doesn't matter; for targets we only note
	    # existence.
	    $contents{$1} = 1;
	    $targets{$1} = 1;
	    local ($cond_string) = join ('', @conditional_stack);
	    if (@conditional_stack)
	    {
		if ($conditional{$1})
		{
		    &check_ambiguous_conditional ($1, $cond_string);
		    $conditional{$1} .= ' ';
		}
		else
		{
		    $conditional{$1} = '';
		}
		$conditional{$1} .= $cond_string . ' 1';
	    }
	    $content_lines{$1} = $.;
	    $output_trailer .= $comment . $spacing . $cond_string . $_;
	    $comment = $spacing = '';
	    $saw_bk = /\\$/;

	    # Check the rule for being a suffix rule. If so, store in
	    # a hash.

	    local ($source_suffix);
	    local ($object_suffix);

	    if (($source_suffix, $object_suffix) = ($1 =~ $SUFFIX_RULE_PATTERN))
	    {
	      $suffix_rules{$source_suffix} = $object_suffix;
	      print "Sources ending in .$source_suffix become .$object_suffix\n" if $verbose;
	      $source_suffix_pattern = "(" . join ('|', keys %suffix_rules) . ")";
	    }

	    # FIXME: make sure both suffixes are in SUFFIXES? Or set
	    # SUFFIXES from suffix_rules?
	}
	elsif (($is_ok_macro = /$MACRO_PATTERN/o)
	       || /$BOGUS_MACRO_PATTERN/o)
	{
	    # Found a macro definition.
	    $was_rule = 0;
	    $last_var_name = $1;
	    if (defined $contents{$1}
		&& (@conditional_stack
		    ? ! defined $conditional{$1}
		    : defined $conditional{$1}))
	    {
		&am_line_error ($1,
				"$1 defined both conditionally and unconditionally");
	    }
	    local ($value);
	    if ($3 ne '' && substr ($3, -1) eq "\\")
	    {
		# We preserve the `\' because otherwise the long lines
		# that are generated will be truncated by broken
		# `sed's.
		$value = $3 . "\n";
	    }
	    else
	    {
		$value = $3;
	    }
	    local ($type) = $2;

	    if (! defined $contents{$last_var_name})
	    {
		# The first assignment to a macro sets the line
		# number.  Ideally I suppose we would associate line
		# numbers with random bits of text.
		$content_lines{$last_var_name} = $.;

		# If first assignment, set `+=' indicator.
		$var_was_plus_eq{$last_var_name} =
		    ($type eq '+'
		     && ! defined $am_var_defs{$last_var_name});
	    }

	    if ($type eq '+')
	    {
		if (! defined $contents{$last_var_name}
		    && defined $am_var_defs{$last_var_name})
		{
		    $contents{$last_var_name} = $am_var_defs{$last_var_name};
		}
		if (substr ($contents{$last_var_name}, -1) eq "\n")
		{
		    # Insert a backslash before a trailing newline.
		    $contents{$last_var_name}
			= substr ($contents{$last_var_name}, 0, -1) . "\\\n";
		}
		$contents{$last_var_name} .= ' ' . $value;
	    }
	    else
	    {
		$contents{$last_var_name} = $value;
	    }
	    local ($cond_string) = join ('', @conditional_stack);
	    if (@conditional_stack)
	    {
		local ($found) = 0;
		local ($val);
		if ($conditional{$last_var_name})
		{
		    if ($type eq '+')
		    {
			# If we're adding to the conditional, and it
			# exists, then we might want to simply replace
			# the old value with the new one.
			local (@new_vals, @cond_vals);
			@cond_vals = split (' ', $conditional{$last_var_name});
			while (@cond_vals)
			{
			    local ($vcond) = shift (@cond_vals);
			    push (@new_vals, $vcond);
			    if (&conditional_same ($vcond, $cond_string))
			    {
				$found = 1;
				$val = (&unquote_cond_val (shift (@cond_vals))
					. ' ' . $value);
				push (@new_vals, &quote_cond_val ($val));
			    }
			    else
			    {
				push (@new_vals, shift (@cond_vals));
			    }
			}
			if ($found)
			{
			    $conditional{$last_var_name}
			        = join (' ', @new_vals);
			}
		    }

		    if (! $found)
		    {
			&check_ambiguous_conditional ($last_var_name,
						      $cond_string);
			$conditional{$last_var_name} .= ' ';
			$val = $value;
		    }
		}
		else
		{
		    $conditional{$last_var_name} = '';
		    $val = $contents{$last_var_name};
		}
		if (! $found)
		{
		    $conditional{$last_var_name} .= ($cond_string
						     . ' '
						     . &quote_cond_val ($val));
		}
	    }

	    # FIXME: this doesn't always work correctly; it will group
	    # all comments for a given variable, no matter where
	    # defined.
	    $am_vars{$last_var_name} = $comment . $spacing;
	    $def_type{$last_var_name} = ($type eq ':') ? ':' : '';
	    push (@var_list, $last_var_name);
	    $comment = $spacing = '';
	    $saw_bk = /\\$/;

	    # Error if bogus.
	    &am_line_error ($., "bad macro name \`$last_var_name'")
		if ! $is_ok_macro;
	}
        elsif (/$INCLUDE_PATTERN/o)
        {
            local ($path) = $1;

            if ($path =~ s/^\$\(top_srcdir\)\///)
            {
                push (@include_stack, "\$\(top_srcdir\)/$path");
            }
            else
            {
                $path =~ s/\$\(srcdir\)\///;
                push (@include_stack, "\$\(srcdir\)/$path");
                $path = $relative_dir . "/" . $path;
            }
            &read_am_file ($path);
        }
	else
        {
	    # This isn't an error; it is probably a continued rule.
	    # In fact, this is what we assume.
	    $was_rule = 1;
	    $output_trailer .= ($comment . $spacing
				. join ('', @conditional_stack) . $_);
	    $comment = $spacing = '';
	    $saw_bk = /\\$/;
	}

	$_ = <AM_FILE>;
    }

    $output_trailer .= $comment;

    if (join (' ', @saved_cond_stack) ne join (' ', @conditional_stack))
    {
	if (@conditional_stack)
	{
	    &am_error ("unterminated conditionals: @conditional_stack");
	}
	else
	{
	    # FIXME: better error message here.
	    &am_error ("conditionals not nested in include file");
	}
    }
}


# define_standard_variables ()
# ----------------------------
# A helper for read_main_am_file which initializes configure variables
# and variables from header-vars.am.  This is a subr so we can call it
# twice.
sub define_standard_variables
{
    # Compute relative location of the top object directory.
    local (@topdir) = ();
    foreach (split (/\//, $relative_dir))
    {
	next if $_ eq '.' || $_ eq '';
	if ($_ eq '..')
	{
	    pop @topdir;
	}
	else
	{
	    push (@topdir, '..');
	}
    }
    @topdir = ('.') if ! @topdir;

    $top_builddir = join ('/', @topdir);
    $output_vars .=
        &file_contents ('header-vars',
			&transform ('top_builddir' => $top_builddir));

    # Generate some useful variables when AC_CANONICAL_* used.  FIXME:
    # this should use generic %configure_vars method.
    if ($seen_canonical)
    {
	local ($curs, %vars);
	$vars{'host_alias'} = 'host_alias';
	$vars{'host_triplet'} = 'host';
	if ($seen_canonical == $AC_CANONICAL_SYSTEM)
	{
	    $vars{'build_alias'} = 'build_alias';
	    $vars{'build_triplet'} = 'build';
	    $vars{'target_alias'} = 'target_alias';
	    $vars{'target_triplet'} = 'target';
	}
	foreach $curs (sort keys %vars)
	{
	    $output_vars .= "$curs = \@$vars{$curs}\@\n";
	    $contents{$curs} = "\@$vars{$curs}\@";
	}
    }

    local ($curs);
    foreach $curs (sort keys %configure_vars)
    {
	&define_configure_variable ($curs);
    }
}

# Read main am file.
sub read_main_am_file
{
    local ($amfile) = @_;

    # The keys here are variables we want to dump at the end of this
    # function.  The values are corresponding comments.
    local (%am_vars) = ();
    local (@var_list) = ();
    local (%def_type) = ();

    # This supports the strange variable tricks we are about to play.
    &prog_error ("variable defined before read_main_am_file")
        if scalar keys %contents > 0;

    # We want to predefine as many variables as possible.  This lets
    # the user set them with `+=' in Makefile.am.  However, we don't
    # want these initial definitions to end up in the output quite
    # yet.  So we adopt a hack: read the `.am' file twice, throwing
    # away the output the first time.  We also squirrel away a list of
    # all the variables defined by the .am file so that we know which
    # ones to remove from the content list.

    # First pass.
    &define_standard_variables;
    local (%saved_contents) = %contents;

    # Read user file, but discard text of variable assignments we just
    # made.
    $output_vars = '';
    &read_am_file ($amfile);

    # Now dump the variables that were defined.  We do it in the same
    # order in which they were defined (skipping duplicates).
    local (%done);
    foreach $curs (@var_list)
    {
	next if $done{$curs};
	$done{$curs} = 1;

	$output_vars .= $am_vars{$curs};
	if ($conditional{$curs})
	{
	    local (@cond_vals) = split (' ', $conditional{$curs});
	    while (@cond_vals)
	    {
		local ($vcond) = shift (@cond_vals);
		local ($val) = &unquote_cond_val (shift (@cond_vals));
		$output_vars .= ($vcond . $curs . ' '
				 . $def_type{$curs} . "= ");
		local ($line);
		foreach $line (split ("\n", $val))
		{
		    $output_vars .= $vcond . $line . "\n";
		}
		$output_vars .= "\n"
		    if $val eq '';
	    }
	}
	else
	{
	    $output_vars .= ($curs . ' ' . $def_type{$curs} . '= '
			     . $contents{$curs} . "\n");
	}
    }

    # Generate copyright header for generated Makefile.in.
    local ($ov) = $output_vars;
    $output_vars = ("# $in_file_name generated automatically by automake "
		   . $VERSION . " from $am_file_name\n");
    $output_vars .= $gen_copyright;

    # Now go through and delete all the variables that the user did
    # not change.
    local ($var);
    foreach $var (keys %saved_contents)
    {
	if ($contents{$var} eq $saved_contents{$var})
	{
	    delete $contents{$var};
	}
    }

    # Re-read the standard variables, and this time keep their
    # contributions to the output.  Then add the user's output to the
    # end.
    &define_standard_variables;
    $output_vars .= $ov;

}

################################################################

sub initialize_global_constants
{
    # Values for AC_CANONICAL_*
    $AC_CANONICAL_HOST = 1;
    $AC_CANONICAL_SYSTEM = 2;

    # Associative array of standard directory names.  Entry is TRUE if
    # corresponding directory should be installed during
    # 'install-exec' phase.
    %exec_dir_p =
	('bin', 1,
	 'sbin', 1,
	 'libexec', 1,
	 'data', 0,
	 'sysconf', 1,
	 'localstate', 1,
	 'lib', 1,
	 'info', 0,
	 'man', 0,
	 'include', 0,
	 'oldinclude', 0,
	 'pkgdata', 0,
	 'pkglib', 1,
	 'pkginclude', 0
	 );

    # Commonly found files we look for and automatically include in
    # DISTFILES.
    @common_files =
	(
	 'README', 'THANKS', 'TODO', 'NEWS', 'COPYING', 'COPYING.LIB',
	 'INSTALL', 'ABOUT-NLS', 'ChangeLog', 'configure.ac',
	 'configure.in', 'configure', 'config.guess', 'config.sub',
	 'AUTHORS', 'BACKLOG', 'ABOUT-GNU', 'libversion.in',
	 'mdate-sh', 'mkinstalldirs', 'install-sh', 'texinfo.tex',
	 'ansi2knr.c', 'ansi2knr.1', 'elisp-comp',
	 # ltconfig appears here for compatibility with old versions
	 # of libtool.
	 'ylwrap', 'acinclude.m4', @libtoolize_files, @libtoolize_sometimes,
	 'missing', 'depcomp', 'compile', 'py-compile'
	 );

    # Commonly used files we auto-include, but only sometimes.
    @common_sometimes =
	(
	 'aclocal.m4', 'acconfig.h', 'config.h.top',
	 'config.h.bot', 'stamp-h.in', 'stamp-vti'
	 );

    $USAGE = "\
  -a, --add-missing     add missing standard files to package
  --amdir=DIR           directory storing config files
  -c, --copy            with -a, copy missing files (default is symlink)
  --cygnus              assume program is part of Cygnus-style tree
  --force-missing       force update of standard files
  --foreign             set strictness to foreign
  --gnits               set strictness to gnits
  --gnu                 set strictness to gnu
  --help                print this help, then exit
  -i, --ignore-deps     disable dependency tracking code
  --include-deps        enable dependency tracking code
  --no-force            only update Makefile.in's that are out of date
  -o DIR, --output-dir=DIR
                        put generated Makefile.in's into DIR
  -v, --verbose         verbosely list files processed
  --version             print version number, then exit\n";

    # Copyright on generated Makefile.ins.
    $gen_copyright = "\
# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000
# Free Software Foundation, Inc.
# This Makefile.in is free software; the Free Software Foundation
# gives unlimited permission to copy and/or distribute it,
# with or without modifications, as long as this notice is preserved.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.
";

    # This complex find command will try to avoid changing the modes of
    # links into the source tree, in case they're hard-linked.  It will
    # also make directories writable by everybody, because some
    # brain-dead tar implementations change ownership and permissions of
    # a directory before extracting the files, thus becoming unable to
    # extract them.
    # Ignore return result from chmod, because it might give an error
    # if we chmod a symlink.
    # Another nastiness: if the file is unreadable by us, we make it
    # readable regardless of the number of links to it.  This only
    # happens in perverse cases.
    # We use $(install_sh) because that is a known-portable way to
    # modify the file in place in the source tree.
    $dist_header = '	-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \; -o \\
	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \\
	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \\
	  ! -type d ! -perm -444 -exec $(SHELL) $(install_sh) -c -m a+r {} {} \; \\
	|| chmod -R a+r $(distdir)
';
    $dist{'dist-bzip2'} = ("\t"
			   . '$(AMTAR) chof - $(distdir) | bzip2 -9 -c > $(distdir).tar.bz2'
			   . "\n");
    $dist{'dist-tarZ'} = ("\t"
		     . '$(AMTAR) chof - $(distdir) | compress -c > $(distdir).tar.Z'
		     . "\n");
    $dist{'dist-shar'} = ("\t"
		     . 'shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c > $(distdir).shar.gz'
		     . "\n");
    $dist{'dist-zip'} = ("\t" . '-rm -f $(distdir).zip' . "\n" .
			 "\t" . 'zip -rq $(distdir).zip $(distdir)' . "\n");

    # Note that we don't use GNU tar's `-z' option.  One reason (but
    # not the only reason) is that some versions of tar (e.g., OSF1)
    # interpret `-z' differently.
    $dist{'dist'} = ("\t"
		     .  '$(AMTAR) chof - $(distdir) | GZIP=$(GZIP_ENV) gzip -c > $(distdir).tar.gz'
		     . "\n");
    $dist_trailer = "\t" . '-chmod -R a+w $(distdir) > /dev/null 2>&1; rm -rf $(distdir)' . "\n";
}

# (Re)-Initialize per-Makefile.am variables.
sub initialize_per_input
{
    # These two variables are used when generating each Makefile.in.
    # They hold the Makefile.in until it is ready to be printed.
    $output_rules = '';
    $output_vars = '';
    $output_trailer = '';
    $output_all = '';
    $output_header = '';

    # Suffixes found during a run.
    @suffixes = ();

    # This holds the contents of a Makefile.am, as parsed by
    # read_am_file.
    %contents = ();

    # This holds the names which are targets.  These also appear in
    # %contents.
    %targets = ();

    # This maps a variable name onto a flag.  The flag is true iff the
    # variable was first defined with `+='.
    %var_was_plus_eq = ();

    # This holds definitions of all variables defined in .am files.
    # This is used during startup to determine which variables can be
    # assigned with `+='.
    %am_var_defs = ();

    # For a variable or target which is defined conditionally, this
    # holds an array of the conditional values.  The array is composed
    # of pairs of condition strings (the variables which configure
    # will substitute) and values (the value of a target is
    # meaningless).  For an unconditional variable, this is empty.
    %conditional = ();

    # This holds the line numbers at which various elements of
    # %contents are defined.
    %content_lines = ();

    # This holds a 1 if a particular variable was examined.
    %content_seen = ();

    # This is the conditional stack.
    @conditional_stack = ();

    # This holds the set of included files.
    @include_stack = ();

    # This holds the "relative directory" of the current Makefile.in.
    # Eg for src/Makefile.in, this is "src".
    $relative_dir = '';

    # This holds a list of files that are included in the
    # distribution.
    %dist_common = ();

    # This holds a list of directories which we must create at `dist'
    # time.  This is used in some strange scenarios involving weird
    # AC_OUTPUT commands.
    %dist_dirs = ();

    # List of dependencies for the obvious targets.
    @install_data = ();
    @install_exec = ();
    @uninstall = ();
    @installdirs = ();

    @info = ();
    @dvi = ();
    @all = ();
    @check = ();
    @check_tests = ();
    @installcheck = ();

    # Holds the dependencies of target which dependencies are factored.
    # Typically, `.PHONY' will appear in plenty of *.am files, but must
    # be output once.  Arguably all pure dependencies could be subject
    # to this factorization, but it is not unpleasant to have paragraphs
    # in Makefile: keeping related stuff altogether.
    %dependencies =
      (
       'clean'  => [],
       '.PHONY' => []
      );

    # A list of files deleted by `maintainer-clean'.
    @maintainer_clean_files = ();

    # These are pretty obvious, too.  They are used to define the
    # SOURCES and OBJECTS variables.
    @sources = ();
    @objects = ();
    # Sources which go in the distribution.
    @dist_sources = ();

    # This hash maps object file names onto their corresponding source
    # file names.  This is used to ensure that each object is created
    # by a single source file.
    %object_map = ();

    # This keeps track of the directories for which we've already
    # created `.dirstamp' code.
    %directory_map = ();

    # These variables track inclusion of various compile-related .am
    # files.  $included_generic_compile is TRUE if the basic code has
    # been included.  $included_knr_compile is TRUE if the ansi2knr
    # code has been included.  $included_libtool_compile is TRUE if
    # libtool support has been included.
    $included_generic_compile = 0;
    $included_knr_compile = 0;
    $included_libtool_compile = 0;

    # TRUE if install targets should work recursively.
    $recursive_install = 0;

    # All .P files.
    %dep_files = ();

    # Strictness levels.
    $strictness = $default_strictness;
    $strictness_name = $default_strictness_name;

    # Options from AUTOMAKE_OPTIONS.
    %options = ();

    # Whether or not dependencies are handled.  Can be further changed
    # in handle_options.
    $use_dependencies = $cmdline_use_dependencies;

    # Per Makefile.am.
    $local_maint_charset = $maint_charset;

    # All yacc and lex source filenames for this directory.  Use
    # filenames instead of raw count so that multiple instances are
    # counted correctly (eg one yacc file can appear in multiple
    # programs without harm).
    %yacc_sources = ();
    %lex_sources = ();

    # This is a list of all targets to run during "make dist".
    @dist_targets = ();

    # Keys in this hash are the basenames of files which must depend
    # on ansi2knr.
    %de_ansi_files = ();

    # This maps the source extension of a suffix rule to its
    # corresponding output extension.
    %suffix_rules = ();

    # This is a regular expression which matches all the known source
    # suffix.  A source suffix is one that appears in the first
    # position of a suffix rule.
    $source_suffix_pattern = '';

    # This is the name of the recursive `all' target to use.
    $all_target = 'all-recursive';

    # This keeps track of which extensions we've seen (that we care
    # about).
    %extension_seen = ();

    # This is random scratch space for the language finish functions.
    # Don't randomly overwrite it; examine other uses of keys first.
    %language_scratch = ();

    # We keep track of which objects need special (per-executable)
    # handling on a per-language basis.
    %lang_specific_files = ();

    # This is set when `handle_dist' has finished.  Once this happens,
    # we should no longer push on dist_common.
    $handle_dist_run = 0;

    # True if we need `LINK' defined.  This is a hack.
    $need_link = 0;
}


################################################################


# $CONTENTS
# &file_contents ($BASENAME, [$COMMAND])
# --------------------------------------
# Return contents of a file from $am_dir, automatically skipping
# macros or rules which are already known.  Runs command on each line
# as it is read; this command can modify $_.
sub file_contents
{
    local ($basename, $command) = @_;
    local ($file) = $am_dir . '/' . $basename . '.am';

    &prog_error ("file_contents: $command")
        if $command ne '' && substr ($command, -1) ne ';';

    open (FC_FILE, $file)
	|| die "automake: installation error: cannot open \`$file'\n";
    # Looks stupid?
    # print "automake: reading $file\n" if $verbose;

    # Swallow into $CONTENTS the whole content of the file, after
    # having performed the $COMMAND, and removed Automake comments.
    local ($contents) = '';

    while (<FC_FILE>)
    {
	$_ =~ s/\@MAINTAINER_MODE_TRUE\@//g
	    unless $seen_maint_mode;

	$had_chars = length ($_) && $_ ne "\n";
        eval $command;
	# If the transform caused all the characters to go away, then
	# ignore the line.  Why do this?  Because in Perl 4, a "next"
	# inside of an eval doesn't affect a loop outside the eval.
	# So we can't pass in a "transform" that uses next.  We used
	# to do this.  "Empty" also means consisting of a single
	# newline.
	next if $had_chars && ($_ eq '' || $_ eq "\n");

	# Merely delete comments beginning with two hashes.
	next if	/$IGNORE_PATTERN/o;

	$contents .= $_;
    }

    close (FC_FILE);

    # We don't need more than two consecutive new-lines.
    $contents =~ s/\n{3,}/\n\n/g;

    # Process each Make `paragraph'.
    #
    # A Make `paragraph' is delimited by a new line which is not
    # escaped, and not followed by a tab or a comment.
    #
    # Frankly, unless you like fighting with Perl (you're a freak!),
    # if I were you I would not try some other implementation, it's
    # very easy falling either into extremely low RE matching
    # (backtracking...), or worse yet: infloop...  For instance, (my)
    # perl goes loopy if you try to
    #
    #  $result_rules =~ /^($TARGET_PATTERN *)+: ($TARGET_PATTERN *)+\n\n/sm
    local ($result_vars) = '';
    local ($result_rules) = '';
    local ($comment) = '';
    foreach (split (/(?<!\\)\n(?![\t#])/, $contents))
    {
	&am_file_error ("$basename.am",
			"blank line following trailing backslash:\n$_")
	  if /\\$/;
	&am_file_error ("$basename.am",
			"comment following trailing backslash:\n$_")
	  if /\\#/;

 	if (/^$/)
 	{
 	    # Stick empty line before the incoming macro or rule.
 	    $separator = "\n";
 	}
 	elsif (/$COMMENT_PATTERN/mso)
 	{
 	    # Stick comments before the incoming macro or rule.
 	    $comment = $_;
 	}
 	elsif (/$RULE_PATTERN/mso && !/\t/ && /^([^:]+): ([^:]+)$/som)
 	{
	    # Pure dependencies: take some Dude, it's good stuff!
	    my ($dependers, $dependees) = ($1, $2);
	    $dependers =~ s/\\\n//somg;
	    $dependees =~ s/\\\n//somg;
	    foreach (split (/\s/ , $dependers))
	    {
	        if (defined $dependencies{$_})
		{
		    &depend ($_, split (/\s/, $dependees));
		}
		else
		{
		    # Free lance dependency.
		    $result_rules .= "$comment$separator$1: $2\n"
		      unless defined $contents{$1};
		    $comment = $separator = '';
		}
	    }
 	}
 	elsif (/$RULE_PATTERN/mso)
 	{
 	    $result_rules .= "$comment$separator$_\n"
	      unless defined $contents{$1};
 	    $comment = $separator = '';
 	}
 	elsif (/$MACRO_PATTERN/mso)
 	{
 	    $result_vars .= "$comment$separator$_\n"
	      unless defined $contents{$1};
 	    $comment = $separator = '';
 	    &prog_error (".am macro \`$1' with trailing backslash at $file:$.")
	      if /\\$/;;
 	    $am_var_defs{$1} = $3;
 	}
 	else
 	{
	    # This isn't an error; it is probably some tokens which
	    # configure is supposed to replace, such as `@SET-MAKE@'.
 	    $result_rules .= "$comment$separator$_\n";
 	    $comment = $separator = '';
 	}
    }

    return $result_vars . $result_rules . $comment;
}


# &transform (%PAIRS)
# -------------------
# Create a replacement expression suitable for file_contents
# to replace each key of %PAIRS by its value.
sub transform
{
    local (%pairs) = @_;
    local ($result) = '';

    local ($quoted);
    foreach $pattern (sort keys %pairs)
    {
	($quoted = $pairs{$pattern}) =~ s/(\W)/\\$1/g;
        $result .= 's,\@' . $pattern . '\@,' . $quoted . ',g;';
    }
    return $result;
}

# Find all variable prefixes that are used for install directories.  A
# prefix `zar' qualifies iff:
# * `zardir' is a variable.
# * `zar_PRIMARY' is a variable.
sub am_primary_prefixes
{
    local ($primary, $can_dist, @prefixes) = @_;

    local (%valid, $varname);
    grep ($valid{$_} = 0, @prefixes);
    $valid{'EXTRA'} = 0;
    foreach $varname (keys %contents)
    {
	if ($varname =~ /^(nobase_)?(dist_|nodist_)?(.*)_$primary$/)
	{
	    if (($2 ne '' && ! $can_dist)
		|| (! defined $valid{$3} && ! &variable_defined ($3 . 'dir')))
	    {
		# Note that a configure variable is always legitimate.
		# It is natural to name such variables after the
		# primary, so we explicitly allow it.
		if (! defined $configure_vars{$varname})
		{
		    &am_line_error ($varname, "invalid variable \`$varname'");
		}
	    }
	    else
	    {
		# Ensure all extended prefixes are actually used.
		$valid{$1 . $2 . $3} = 1;
	    }
	}
    }

    return %valid;
}

# Handle `where_HOW' variable magic.  Does all lookups, generates
# install code, and possibly generates code to define the primary
# variable.  The first argument is the name of the .am file to munge,
# the second argument is the primary variable (eg HEADERS), and all
# subsequent arguments are possible installation locations.  Returns
# list of all values of all _HOW targets.
#
# FIXME: this should be rewritten to be cleaner.  It should be broken
# up into multiple functions.
#
# Usage is: am_install_var (OPTION..., file, HOW, where...)
sub am_install_var
{
    local (@args) = @_;

    local ($do_clean) = 0;
    local ($do_require) = 1;
    local ($can_dist) = 0;
    local ($default_dist) = 0;

    local ($ltxform);
    if (defined $configure_vars{'LIBTOOL'})
    {
	# Transform '@LIBTOOL ...@' to '$(LIBTOOL) ...'
	$ltxform = 's/\@LIBTOOL([^\@]*)\@/\$(LIBTOOL) $1/;';
    }
    else
    {
	# Delete '@LIBTOOL ...@'
	$ltxform = 's/\@LIBTOOL([^\@]*)\@//;';
    }

    local ($cygxform);
    if (! $seen_exeext)
    {
	$cygxform = 's/\@EXEEXT\@//g;';
    }
    else
    {
	$cygxform = 's/\@EXEEXT\@/\$(EXEEXT)/g;';
    }

    while (@args)
    {
	if ($args[0] eq '-clean')
	{
	    $do_clean = 1;
	}
	elsif ($args[0] eq '-noextra')
	{
	    $do_require = 0;
	}
	elsif ($args[0] eq '-candist')
	{
	    $can_dist = 1;
	}
	elsif ($args[0] eq '-defaultdist')
	{
	    $default_dist = 1;
	    $can_dist = 1;
	}
	elsif ($args[0] !~ /^-/)
	{
	    last;
	}
	shift (@args);
    }

    local ($file, $primary, @prefixes) = @args;

    local (@used) = ();
    local (@result) = ();

    # Now that configure substitutions are allowed in where_HOW
    # variables, it is an error to actually define the primary.  We
    # allow `JAVA', as it is customarily used to mean the Java
    # interpreter.  This is but one of several Java hacks.  Similarly,
    # `PYTHON' is customarily used to mean the Python interpreter.
    &am_line_error ($primary, "\`$primary' is an anachronism")
	if &variable_defined ($primary)
	    && ($primary ne 'JAVA' && $primary ne 'PYTHON');


    # Look for misspellings.  It is an error to have a variable ending
    # in a "reserved" suffix whose prefix is unknown, eg
    # "bni_PROGRAMS".  However, unusual prefixes are allowed if a
    # variable of the same name (with "dir" appended) exists.  For
    # instance, if the variable "zardir" is defined, then
    # "zar_PROGRAMS" becomes valid.  This is to provide a little extra
    # flexibility in those cases which need it.
    local (%valid) = &am_primary_prefixes ($primary, $can_dist, @prefixes);

    # If a primary includes a configure substitution, then the EXTRA_
    # form is required.  Otherwise we can't properly do our job.
    local ($require_extra);
    local ($warned_about_extra) = 0;

    local ($clean_file) = $file . '-clean';
    local ($one_name);
    local ($X);
    local ($nodir_name);
    local ($strip_subdir) = 1;
    foreach $X (sort keys %valid)
    {
	$one_name = $X . '_' . $primary;
	if (&variable_defined ($one_name))
	{
	    # If subdir prefix should be preserved, do so.
	    if ($X =~ /^nobase_/)
	    {
		$strip_subdir = 0;
		$X =~ s/^nobase_//;
	    }

	    # If files should be distributed, do so.
	    if ($can_dist)
	    {
		if (($default_dist && $one_name !~ /^nodist_/)
		    || (! $default_dist && $one_name =~ /^dist_/))
		{
		    &push_dist_common ('$(' . $one_name . ')');
		}
		($nodir_name = $X) =~ s/^(dist|nodist)_//;
	    }
	    else
	    {
		$nodir_name = $X;
	    }

	    # Append actual contents of where_PRIMARY variable to
	    # result.
	    local ($rcurs);
	    foreach $rcurs (&variable_value_as_list ($one_name, 'all'))
	    {
		# Skip configure substitutions.  Possibly bogus.
		if ($rcurs =~ /^\@.*\@$/)
		{
		    if ($X eq 'EXTRA')
		    {
			if (! $warned_about_extra)
			{
			    $warned_about_extra = 1;
			    {
				&am_line_error ($one_name,
						"\`$one_name' contains configure substitution, but shouldn't");
			    }
			}
		    }
		    # Check here to make sure variables defined in
		    # configure.ac do not imply that EXTRA_PRIMARY
		    # must be defined.
		    elsif (! defined $configure_vars{$one_name})
		    {
			$require_extra = $one_name
			    if $do_require;
		    }

		    next;
		}

		push (@result, $rcurs);
	    }

	    # A blatant hack: we rewrite each _PROGRAMS primary to
	    # include EXEEXT when in Cygwin32 mode.
	    if ($seen_exeext && $primary eq 'PROGRAMS')
	    {
		local (@conds) = &variable_conditions ($one_name);
		local (@one_binlist);

		# FIXME: this definitely loses aesthetically; it
		# redefines $ONE_NAME.  Instead we should arrange for
		# variable definitions to be output later, instead of
		# at scan time.

		if (! @conds)
		{
		    @one_binlist = ();
		    foreach $rcurs (&variable_value_as_list ($one_name, ''))
		    {
			if ($rcurs =~ /\./ || $rcurs =~ /^\@.*\@$/)
			{
			    push (@one_binlist, $rcurs);
			}
			else
			{
			    push (@one_binlist, $rcurs . '$(EXEEXT)');
			}
		    }

		    delete $contents{$one_name};
		    &define_pretty_variable ($one_name, '', @one_binlist);
		}
		else
		{
		    local ($cond);
		    local ($condvals) = '';
		    foreach $cond (@conds)
		    {
			@one_binlist = ();
			local (@condval) = &variable_value_as_list ($one_name,
								    $cond);
			foreach $rcurs (@condval)
			{
			    if ($rcurs =~ /\./ || $rcurs =~ /^\@.*\@$/)
			    {
				push (@one_binlist, $rcurs);
			    }
			    else
			    {
				push (@one_binlist, $rcurs . '$(EXEEXT)');
			    }
			}

			push (@condvals, $cond);
			push (@condvals, join (' ', @one_binlist));
		    }

		    delete $contents{$one_name};

		    while (@condvals)
		    {
			$cond = shift (@condvals);
			local (@val) = split (' ', shift (@condvals));
			&define_pretty_variable ($one_name, $cond, @val);
		    }
		}
	    }

	    # "EXTRA" shouldn't be used when generating clean targets,
	    # all, or install targets.
	    if ($X eq 'EXTRA')
	    {
		# We used to warn if EXTRA_FOO was defined uselessly,
		# but this was annoying.
		next;
	    }

	    if ($do_clean)
	    {
		$output_rules .=
		  &file_contents ($clean_file,
				  &transform ('DIR' => $X)
				  . $cygxform);

		&depend ('clean', $X . $primary);
		&push_phony_cleaners ($X . $primary);
	    }

	    if ($X eq 'check')
	    {
		push (@check, '$(' . $one_name . ')');
	    }
	    else
	    {
		push (@used, '$(' . $one_name . ')');
	    }
	    if ($X eq 'noinst' || $X eq 'check')
	    {
		# Objects which don't get installed by default.
		next;
	    }

	    local ($subdir_xform);
	    if ($strip_subdir)
	    {
		$subdir_xform = 's/^NOBASE.*$//; s/^BASE//;';
	    }
	    else
	    {
		$subdir_xform = 's/^BASE.*$//; s/^NOBASE//;';
	    }

	    $output_rules .=
	      &file_contents ($file,
			      &transform ('DIR'  => $X,
					  'NDIR' => $nodir_name)
			      . $ltxform
			      . $cygxform
			      . $subdir_xform);

	    push (@uninstall, 'uninstall-' . $X . $primary);
	    &depend ('.PHONY', 'uninstall-' . $X . $primary);
	    push (@installdirs, '$(DESTDIR)$(' . $X . 'dir)');
	    if (defined $exec_dir_p{$X} ? $exec_dir_p{$X} : ($X =~ /exec/))
	    {
		push (@install_exec, 'install-' . $X . $primary);
		&depend ('.PHONY', 'install-' . $X . $primary);
	    }
	    else
	    {
		push (@install_data, 'install-' . $X . $primary);
		&depend ('.PHONY', 'install-' . $X . $primary);
	    }
	}
    }

    # The JAVA variable is used as the name of the Java interpreter.
    # The PYTHON variable is used as the name of the Python interpreter.
    if (@used && $primary ne 'JAVA' && $primary ne 'PYTHON')
    {
	# Define it.
	&define_pretty_variable ($primary, '', @used);
	$output_vars .= "\n";
    }

    if ($require_extra && ! &variable_defined ('EXTRA_' . $primary))
    {
	&am_line_error ($require_extra,
			"\`$require_extra' contains configure substitution, but \`EXTRA_$primary' not defined");
    }

    # Push here because PRIMARY might be configure time determined.
    push (@all, '$(' . $primary . ')')
	if @used && $primary ne 'JAVA' && $primary ne 'PYTHON';

    # Make the result unique.  This lets the user use conditionals in
    # a natural way, but still lets us program lazily -- we don't have
    # to worry about handling a particular object more than once.
    local (%uniquify) = ();
    grep ($uniquify{$_} = 1, @result);
    return sort keys %uniquify;
}


################################################################

# Each key in this hash is the name of a directory holding a
# Makefile.in.  These variables are local to `is_make_dir'.
%make_dirs = ();
$make_dirs_set = 0;

sub is_make_dir
{
    local ($dir) = @_;
    if (! $make_dirs_set)
    {
	foreach $iter (@configure_input_files)
	{
	    $make_dirs{&dirname ($iter)} = 1;
	}
	# We also want to notice Makefile.in's.
	foreach $iter (@other_input_files)
	{
	    if ($iter =~ /Makefile\.in$/)
	    {
		$make_dirs{&dirname ($iter)} = 1;
	    }
	}
	$make_dirs_set = 1;
    }
    return defined $make_dirs{$dir};
}

################################################################

# This variable is local to the "require file" set of functions.
@require_file_paths = ();

# If a file name appears as a key in this hash, then it has already
# been checked for.  This variable is local to the "require file"
# functions.
%require_file_found = ();

# See if we want to push this file onto dist_common.  This function
# encodes the rules for deciding when to do so.
sub maybe_push_required_file
{
    local ($dir, $file, $fullfile) = @_;

    # FIXME: Once again, special-case `.'.
    if ($dir eq $relative_dir || $dir eq '.')
    {
	&push_dist_common ($file);
    }
    elsif ($relative_dir eq '.' && ! &is_make_dir ($dir))
    {
	# If we are doing the topmost directory, and the file is in a
	# subdir which does not have a Makefile, then we distribute it
	# here.
	&push_dist_common ($fullfile);
    }
}

# Verify that the file must exist in the current directory.  Usage:
# require_file (isconfigure, line_number, strictness, file) strictness
# is the strictness level at which this file becomes required.  Must
# set require_file_paths before calling this function.
# require_file_paths is set to hold a single directory (the one in
# which the first file was found) before return.
sub require_file_internal
{
    local ($is_configure, $line, $mystrict, @files) = @_;
    local ($file, $fullfile);
    local ($found_it, $dangling_sym, $errfile, $errdir);
    local ($save_dir);

    foreach $file (@files)
    {
	# If we've already looked for it, we're done.
	next if defined $require_file_found{$file};
	$require_file_found{$file} = 1;

	$found_it = 0;
	$dangling_sym = 0;
	foreach $dir (@require_file_paths)
	{
	    if ($dir eq '.')
	    {
		$fullfile = $relative_dir . "/" . $file;
		$errdir = $relative_dir unless $errdir;
	    }
	    else
	    {
		$fullfile = $dir . "/" . $file;
		$errdir = $dir unless $errdir;
	    }

	    # Use different name for "error filename".  Otherwise on
	    # an error the bad file will be reported as eg
	    # `../../install-sh' when using the default
	    # config_aux_path.
	    $errfile = $errdir . '/' . $file;

	    if (-l $fullfile && ! -f readlink ($fullfile))
	    {
		$dangling_sym = 1;
		last;
	    }
	    elsif (-f $fullfile)
	    {
		$found_it = 1;
		&maybe_push_required_file ($dir, $file, $fullfile);
		$save_dir = $dir;
		last;
	    }
	}

	if ($found_it && ! $force_missing)
	{
	    # Prune the path list.
	    @require_file_paths = $save_dir;
	}
	else
	{
	    if ($strictness >= $mystrict)
	    {
		if ($dangling_sym && ($force_missing || $add_missing))
		{
		    unlink ($fullfile);
		}

		local ($trailer) = '';
		local ($suppress) = 0;

		# Only install missing files according to our desired
		# strictness level.
		local ($message) = "required file \`$errfile' not found";
		if ($add_missing)
		{
		    $suppress = 1;

		    # Maybe run libtoolize.
		    local @syslist = ('libtoolize', '--automake');
		    push @syslist, '--copy'
			if $copy_missing;
		    if ($seen_libtool
			&& grep ($_ eq $file, @libtoolize_files)
			&& system (@syslist))
		    {
			$message = "installing \`$errfile'";
			$suppress = 0;
			$trailer = "; cannot run \`libtoolize': $!";
		    }
		    elsif (-f ($am_dir . '/' . $file))
		    {
			# Install the missing file.  Symlink if we
			# can, copy if we must.  Note: delete the file
			# first, in case it is a dangling symlink.
			$message = "installing \`$errfile'";
			# Windows Perl will hang if we try to delete a
			# file that doesn't exist.
			unlink ($errfile) if -f $errfile;
			if ($symlink_exists && ! $copy_missing)
			{
			    if (! symlink ($am_dir . '/' . $file, $errfile))
			    {
				$suppress = 0;
				$trailer = "; error while making link: $!";
			    }
			}
			elsif (system ('cp', $am_dir . '/' . $file, $errfile))
			{
			    $suppress = 0;
			    $trailer = "\n    error while copying";
			}
		    }

		    &maybe_push_required_file (&dirname ($errfile),
					       $file, $errfile);
		}

		local ($save) = $exit_status;
		if ($is_configure)
		{
		    # FIXME: allow actual file to be specified.
		    &am_conf_line_error ($configure_ac, $line,
					 "$message$trailer");
		}
		else
		{
		    &am_line_error ($line, "$message$trailer");
		}
		$exit_status = $save if $suppress;
	    }
	}
    }
}

# Like require_file_with_line, but error messages refer to
# configure.ac, not the current Makefile.am.
sub require_file_with_conf_line
{
    @require_file_paths = '.';
    &require_file_internal (1, @_);
}

sub require_file_with_line
{
    @require_file_paths = '.';
    &require_file_internal (0, @_);
}

sub require_file
{
    @require_file_paths = '.';
    &require_file_internal (0, '', @_);
}

# Require a file that is also required by Autoconf.  Looks in
# configuration path, as specified by AC_CONFIG_AUX_DIR.
sub require_config_file
{
    @require_file_paths = @config_aux_path;
    &require_file_internal (1, '', @_);
    local ($dir) = $require_file_paths[0];
    @config_aux_path = @require_file_paths;
    if ($dir eq '.')
    {
	$config_aux_dir = '.';
    }
    else
    {
	$config_aux_dir = '$(top_srcdir)/' . $dir;
    }
}

# Assumes that the line number is in Makefile.am.
sub require_conf_file_with_line
{
    @require_file_paths = @config_aux_path;
    &require_file_internal (0, @_);
    local ($dir) = $require_file_paths[0];
    @config_aux_path = @require_file_paths;
    if ($dir eq '.')
    {
	$config_aux_dir = '.';
    }
    else
    {
	$config_aux_dir = '$(top_srcdir)/' . $dir;
    }
}

# Assumes that the line number is in configure.ac.
sub require_conf_file_with_conf_line
{
    @require_file_paths = @config_aux_path;
    &require_file_internal (1, @_);
    local ($dir) = $require_file_paths[0];
    @config_aux_path = @require_file_paths;
    if ($dir eq '.')
    {
	$config_aux_dir = '.';
    }
    else
    {
	$config_aux_dir = '$(top_srcdir)/' . $dir;
    }
}

################################################################

# Push a list of files onto dist_common.
sub push_dist_common
{
    local (@files) = @_;
    local ($file);

    foreach $file (@files)
    {
	if (! defined $dist_common{$file})
	{
	    &prog_error ("push_dist_common run after handle_dist")
	        if $handle_dist_run;
	    $dist_common{$file} = 1;
	}
    }
}

# Push a list of clean targets onto phony.
sub push_phony_cleaners
{
    local ($base) = @_;
    local ($target);
    foreach $target ('mostly', 'dist', '', 'maintainer-')
    {
	&depend ('.PHONY', $target . 'clean-' . $base);
    }
}

# Set strictness.
sub set_strictness
{
    $strictness_name = $_[0];
    if ($strictness_name eq 'gnu')
    {
	$strictness = $GNU;
    }
    elsif ($strictness_name eq 'gnits')
    {
	$strictness = $GNITS;
    }
    elsif ($strictness_name eq 'foreign')
    {
	$strictness = $FOREIGN;
    }
    else
    {
	die "automake: level \`$strictness_name' not recognized\n";
    }
}


################################################################

# Return directory name of file.
sub dirname
{
    local ($file) = @_;
    local ($sub);

    ($sub = $file) =~ s,/+[^/]+$,,g;
    $sub = '.' if $sub eq $file;
    return $sub;
}

# Return file name of a file.
sub basename
{
    local ($file) = @_;
    local ($sub);

    ($sub = $file) =~s,^.*/+,,g;
    return $sub;
}

# Ensure a file exists.
sub create
{
    local ($file) = @_;

    open (TOUCH, ">> $file");
    close (TOUCH);
}

# Glob something.  Do this to avoid indentation screwups everywhere we
# want to glob.  Gross!
sub my_glob
{
    local ($pat) = @_;
    return <${pat}>;
}

################################################################

# Print an error message and set exit status.
sub am_error
{
    warn "automake: ${am_file}.am: @_\n";
    $exit_status = 1;
}


# am_file_error ($FILE, @ARGS)
# ----------------------------
sub am_file_error
{
    my ($file, @args) = @_;

    warn "$file: @args\n";
    $exit_status = 1;
}

sub am_line_error
{
    local ($symbol, @args) = @_;

    if ($symbol && "$symbol" ne '-1')
    {
	local ($file) = "${am_file}.am";

	if ($symbol =~ /^\d+$/)
	{
	    # SYMBOL is a line number, so just add the colon.
	    $file .= ':' . $symbol;
	}
	elsif (defined $content_lines{$symbol})
	{
	    # SYMBOL is a variable defined in Makefile.am, so add the
	    # line number we saved from there.
	    $file .= ':' . $content_lines{$symbol};
	}
	elsif (defined $configure_vars{$symbol})
	{
	    # SYMBOL is a variable defined in configure.ac, so add the
	    # appropriate line number.
	    $file = $configure_vars{$symbol};
	}
	else
	{
	    # Couldn't find the line number.
	}
	warn $file, ": @args\n";
	$exit_status = 1;
    }
    else
    {
	&am_error (@args);
    }
}

# Like am_error, but while scanning configure.ac.
sub am_conf_error
{
    # FIXME: can run in subdirs.
    warn "automake: $configure_ac: @_\n";
    $exit_status = 1;
}

# Error message with line number referring to configure.ac.
sub am_conf_line_error
{
    local ($file, $line, @args) = @_;

    if ($line)
    {
	warn "$file: $line: @args\n";
	$exit_status = 1;
    }
    else
    {
	&am_conf_error (@args);
    }
}

# Warning message with line number referring to configure.ac.
# Does not affect exit_status
sub am_conf_line_warning
{
    local ($saved_exit_status) = $exit_status;
    &am_conf_line_error (@_);
    $exit_status = $saved_exit_status;
}

# Tell user where our aclocal.m4 is, but only once.
sub keyed_aclocal_warning
{
    local ($key) = @_;
    warn "automake: macro \`$key' can be generated by \`aclocal'\n";
}

# Print usage information.
sub usage
{
    print "Usage: automake [OPTION] ... [Makefile]...\n\n";
    print "Generate Makefile.in for autoconf from Makefile.am\n";
    print $USAGE;
    print "\nFiles which are automatically distributed, if found:\n";
    $~ = "USAGE_FORMAT";
    local ($last, $iter, @lcomm);
    $last = '';
    foreach $iter (sort ((@common_files, @common_sometimes)))
    {
	push (@lcomm, $iter) unless $iter eq $last;
	$last = $iter;
    }

    local ($one, $two, $three, $four, $i, $max);
    $max = int (($#lcomm + 1) / 4);

    for ($i = 0; $i < $max; ++$i)
    {
	$one = $lcomm[$i];
	$two = $lcomm[$max + $i];
	$three = $lcomm[2 * $max + $i];
	$four = $lcomm[3 * $max + $i];
	write;
    }

    local ($mod) = ($#lcomm + 1) % 4;
    if ($mod != 0)
    {
	$one = $lcomm[$max];
	$two = ($mod > 1) ? $lcomm[2 * $max] : '';
	$three = ($mod > 2) ? $lcomm[3 * $max] : '';
	$four = ($mod > 3) ? $lcomm[4 * $max] : '';
	write;
    }

    print "\nReport bugs to <bug-automake\@gnu.org>.\n";

    exit 0;
}

format USAGE_FORMAT =
  @<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<
  $one,               $two,               $three,             $four
.
